<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="GF.L">
  
  
  
  <link rel="prev" href="https://keep-zero.github.io/2019/spring_action06/" />
  <link rel="next" href="https://keep-zero.github.io/2019/spring_action09/" />
  <link rel="canonical" href="https://keep-zero.github.io/2019/spring_action07/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/images/favicon/safari-pinned-tab.svg" color="#5bbad5">
  
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           《Spring实战》-第七章:SpringMVC的高级技术 | Keep Zero
       
  </title>
  <meta name="title" content="《Spring实战》-第七章:SpringMVC的高级技术 | Keep Zero">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/keep-zero.github.io"
    },
    "articleSection" : "posts",
    "name" : "《Spring实战》-第七章:SpringMVC的高级技术",
    "headline" : "《Spring实战》-第七章:SpringMVC的高级技术",
    "description" : "慢慢来比较快，虚心学技术\n 一、SpringMVC配置的替代方案 Ⅰ、注册Filter SpingMVC的AbstractAnnotationConfigDispatcherServletInitializer提供了十分方便的注册过滤器的方法，通过重载getServletFilters()方法将我们自定义的过滤器注册到上下文中\n如下代码：\npublic class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { private final Logger logger = LoggerFactory.getLogger(this.getClass()); \/*AbstractAnnotationConfigDispatcherServletInitializer 会同时创 建 DispatcherServlet 和 ContextLoaderListener 。 GetServlet-ConfigClasses() 方法返回的带有 @Configuration 注解的 类将会用来定义 DispatcherServlet 应用上下文中的 bean 。 getRootConfigClasses() 方法返回的带有 @Configuration 注解的类将 会用来配置 ContextLoaderListener 创建的应用上下文中的 bean 。*\/ @Override protected Class\x26lt;?\x26gt;[] getRootConfigClasses() { return new Class[]{RootConfig.class}; } @Override protected Class\x26lt;?\x26gt;[] getServletConfigClasses() { return new Class[]{WebConfig.class}; } @Override protected String[] getServletMappings() { logger.debug(\x26quot;DispatcherServlet获取匹配的前端控制器。。。。。。\x26quot;); return new String[]{\x26quot;\/\x26quot;}; } \/** * 注册过滤器 *\/ @Override protected Filter[] getServletFilters() { \/\/将自定义过滤器实例数组返回 return new Filter[]{new MyFilter()}; } } \/** * 过滤器类 *\/ public class MyFilter implements Filter { private Logger logger = LoggerFactory.",
    "inLanguage" : "en-us",
    "author" : "GF.L",
    "creator" : "GF.L",
    "publisher": "GF.L",
    "accountablePerson" : "GF.L",
    "copyrightHolder" : "GF.L",
    "copyrightYear" : "2019",
    "datePublished": "2019-08-31 23:21:13 \x2b0800 CST",
    "dateModified" : "2019-08-31 23:21:13 \x2b0800 CST",
    "url" : "https:\/\/keep-zero.github.io\/2019\/spring_action07\/",
    "wordCount" : "748",
    "keywords" : [ "java","spring","spring-action", "Keep Zero"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://keep-zero.github.io">Keep Zero</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://keep-zero.github.io">Keep Zero</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">《Spring实战》-第七章:SpringMVC的高级技术</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://keep-zero.github.io" rel="author">GF.L</a> with ♥ 
                <span class="post-time">
                on <time datetime=2019-08-31 itemprop="datePublished">August 31, 2019</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://keep-zero.github.io/categories/spring/"> spring </a>
                        
                </span>
				
				<span id="wc" style="font-size: 1rem;text-align: center;">  共800 字|  阅读需时约 4 分|  本文总阅读量<span id="busuanzi_value_page_pv"></span>次</span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          

<blockquote>
<p><strong>慢慢来比较快，虚心学技术</strong></p>
</blockquote>

<h2 id="一-springmvc配置的替代方案">一、SpringMVC配置的替代方案</h2>

<h3 id="ⅰ-注册filter">Ⅰ、注册Filter</h3>

<p>SpingMVC的<strong>AbstractAnnotationConfigDispatcherServletInitializer</strong>提供了十分方便的注册过滤器的方法，通过重载<strong>getServletFilters()</strong>方法将我们自定义的过滤器注册到上下文中</p>

<p>如下代码：</p>

<pre><code class="language-java">public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    /*AbstractAnnotationConfigDispatcherServletInitializer 会同时创
    建 DispatcherServlet 和 ContextLoaderListener 。 GetServlet-ConfigClasses() 方法返回的带有 @Configuration 注解的
    类将会用来定义 DispatcherServlet 应用上下文中的 bean 。 getRootConfigClasses() 方法返回的带有 @Configuration 注解的类将
    会用来配置 ContextLoaderListener 创建的应用上下文中的 bean 。*/

    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return new Class[]{RootConfig.class};
    }

    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class[]{WebConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        logger.debug(&quot;DispatcherServlet获取匹配的前端控制器。。。。。。&quot;);
        return new String[]{&quot;/&quot;};
    }

    /**
     * 注册过滤器
     */
    @Override
    protected Filter[] getServletFilters() {
        //将自定义过滤器实例数组返回
        return new Filter[]{new MyFilter()};
    }
}

/**
 * 过滤器类
 */
public class MyFilter implements Filter {

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        logger.debug(&quot;过滤器初始化&quot;);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        logger.debug(&quot;执行过滤器&quot;);

        Map&lt;String, String[]&gt; parameterMap = servletRequest.getParameterMap();

        Set&lt;String&gt; keySet = parameterMap.keySet();

        for(String key : keySet){
            logger.debug(&quot;参数名：{},参数值：{}&quot;,key,parameterMap.get(key));
        }

        /**
         * 执行该方法，如果有下一个过滤器则执行下一个过滤器，如果没有，则执行目标方法
         * 如果不执行该方法，将无法访问目标路径请求
         */
        filterChain.doFilter(servletRequest,servletResponse);
    }

    @Override
    public void destroy() {

    }
}
</code></pre>

<p>页面访问结果
<figure><img src="/images/ring.svg" data-sizes="auto" data-src="/images/post_resource/spring-action/spring_action_07_01.jpg" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure></p>

<pre><code class="language-properties">2019-03-07 17:19:53.859 DEBUG com.my.spring.filter.MyFilter - 执行过滤器
2019-03-07 17:19:53.860 DEBUG com.my.spring.filter.MyFilter - 参数名：data,参数值：[{'id':0}]
2019-03-07 17:19:53.863 DEBUG org.springframework.web.servlet.DispatcherServlet - GET &quot;/SpringAction07/getBean?data={%27id%27:0}&quot;, parameters={masked}
</code></pre>

<h3 id="ⅱ-xml配置springmvc">Ⅱ、XML配置SpringMVC</h3>

<p>如果是在Servlet3.0以下环境（tomcat7.0以下），使用纯注解实现SpringMVC就不可能实现了，这时候我们需要借助web.xml文件进行配置，但是我们并不希望全部使用xml进行配置，所以我们可以简单配置初始化的内容，其他配置仍使用javaConfig配置方式。</p>

<p>将SpittrWebAppInitializer初始化类去除，使用web.xml代替：</p>

<pre><code class="language-xml">&lt;!DOCTYPE web-app PUBLIC
 &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;
 &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;

&lt;web-app&gt;
  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;

  &lt;!--配置使用java配置--&gt;
  &lt;context-param&gt;
   &lt;param-name&gt;contextClass&lt;/param-name&gt;
   &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;
  &lt;/context-param&gt;

  &lt;!--指定根配置类:RootConfig--&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;com.my.spring.config.RootConfig&lt;/param-value&gt;
  &lt;/context-param&gt;

  &lt;!--注册ContextLoaderListener--&gt;
  &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
  &lt;/listener&gt;

  &lt;!--注册DispatcherServlet--&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--使用java配置--&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextClass&lt;/param-name&gt;
      &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;/param-value&gt;
    &lt;/init-param&gt;

    &lt;!--指定DispatcherServlet配置类:WebConfig--&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;com.my.spring.config.WebConfig&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>

<p>启动应用，访问正常！</p>

<h2 id="二-处理文件上传multipart">二、处理文件上传multipart</h2>

<p>前面所遇到的表单处理，我们处理的都是简单的字符串形式提交，但是上传文件进行提交是一个应用十分常见的需求，文件上传提交的格式是multipart格式，自然不可以像处理字符串形式参数一样去处理。SpringMVC提供了MultipartFile接口用来处理上传的文件：</p>

<pre><code class="language-java">public interface MultipartFile extends InputStreamSource {
    String getName();

    @Nullable
    String getOriginalFilename();

    @Nullable
    String getContentType();

    boolean isEmpty();

    long getSize();

    byte[] getBytes() throws IOException;

    InputStream getInputStream() throws IOException;

    default Resource getResource() {
        return new MultipartFileResource(this);
    }

    void transferTo(File var1) throws IOException, IllegalStateException;

    default void transferTo(Path dest) throws IOException, IllegalStateException {
        FileCopyUtils.copy(this.getInputStream(), Files.newOutputStream(dest));
    }
}
</code></pre>

<p>可以看到，MultipartFile接口可以用来获取文件名，文件大小等信息，还提供了一个InputStream,用来将文件以流的方式读取，还提供了一个便利的 transferTo() 方法，它能够帮助我们将上传的文件写入到文件系统中。</p>

<p>使用MultiparFile实现文件上传之前需要先配置Multipart解析器MultipartResolver，Spring3.1后内置两个MultipartResolver的实现供我们选择：</p>

<ul>
<li><strong>CommonsMultipartResolver</strong>: 使用<strong>Jakarta Commons FileUpload</strong>解析multipart请求。</li>
<li><strong>StandardServletMultipartResolver</strong>: 依赖于<strong>Servlet3.0</strong>对multipart请求的支持。</li>
</ul>

<p>一般来说，<strong>StandardServletMultipartResolver</strong>会是更好的方案，因为它并不需要依赖于其他项目，使用原生的Servlet支持。只不过它只支持Servlet3.0以上的版本，如果低于等于Servlet3.0环境，需要使用CommonsMultipartResolver实现</p>

<h3 id="ⅰ-使用standardservletmultipartresolver实现文件上传">Ⅰ、使用StandardServletMultipartResolver实现文件上传</h3>

<p>①配置解析器，在上文代码的WebConfig中配置</p>

<pre><code class="language-java">public class WebConfig extends WebMvcConfigurationSupport {

    /**
     * 定义一个视图解析器
     *
     **/
    @Bean
    public ViewResolver viewResolver(){
        InternalResourceViewResolver resourceViewResolver = new InternalResourceViewResolver();
        resourceViewResolver.setPrefix(&quot;/WEB-INF/view/&quot;);
        resourceViewResolver.setSuffix(&quot;.jsp&quot;);
        resourceViewResolver.setExposeContextBeansAsAttributes(true);
        resourceViewResolver.setViewClass(org.springframework.web.servlet.view.JstlView.class);
        return resourceViewResolver;
    }

    /**
     * 配置Multipart解析器
     *
     */
    @Bean
    public MultipartResolver multipartResolver(){
        return new StandardServletMultipartResolver();
    }

    @Override
    protected void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }
}
</code></pre>

<p>②在<strong>SpittrWebAppInitializer</strong>中配置文件上传的初始化参数（必须）</p>

<pre><code class="language-java">//通过重载customizeRegistration()方法来配置multipart的默认参数
@Override
protected void customizeRegistration(ServletRegistration.Dynamic registration) {
    registration.setMultipartConfig(               
            new MultipartConfigElement(&quot;C:\\Users\\xxx\\Desktop\\uploads&quot;,2097152,4194304,20000000));
    //设置写入的临时路径（可绝对路径）
    //上传文件的最大容量（字节为单位），默认无限制。
    //整个multipart请求的最大容量（字节为单位），默认无限制。
    //在上传的过程中，如果文件大小达到了一个指定的最大容量，将会写入到临时文件路劲中。默认为0，也就是上传的文件都会写入到磁盘上。
}
</code></pre>

<p>③编写文件上传controller方法</p>

<pre><code class="language-java">@RequestMapping(value = &quot;/upload&quot;,method = RequestMethod.POST)
public String upload(@RequestPart(&quot;file&quot;) MultipartFile multipartFile, Model model) throws IOException {

    String fileName = new String(multipartFile.getOriginalFilename().getBytes(&quot;utf-8&quot;));
    //使用multipartFile的transferTo方法将文件存放到桌面
    multipartFile.transferTo(new File(&quot;C:\\Users\\xxx\\Desktop\\&quot;+multipartFile.getOriginalFilename()));

    model.addAttribute(&quot;fileName&quot;,fileName);
    model.addAttribute(&quot;fileSize&quot;,multipartFile.getSize());

    return &quot;showFile&quot;;
}
</code></pre>

<p>④编写上传文件的JSP</p>

<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;body&gt;
&lt;h2&gt;Hello World!&lt;/h2&gt;
    &lt;!--此处必须设置form的enctype属性设置为multipart/form-data，否则会报CrrentRquest not a MultipartFile Request--&gt;
    &lt;form action=&quot;./upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
        &lt;label&gt;文件;&lt;/label&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;
        &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>⑤编写文件信息视图：showFile.jsp</p>

<pre><code class="language-jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page isELIgnored=&quot;false&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;文件展示&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
文件名称：
&lt;c:out value=&quot;${fileName}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
文件大小：
&lt;c:out value=&quot;${fileSize}&quot;&gt;&lt;/c:out&gt;KB
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>页面效果：</p>

<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/images/post_resource/spring-action/spring_action_07_02.jpg" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure>
点击提交，将文件提交至服务器，上传成功
<figure><img src="/images/ring.svg" data-sizes="auto" data-src="/images/post_resource/spring-action/spring_action_07_03.jpg" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure></p>

<h3 id="ⅱ-使用commonsmultipartresolver实现文件上传">Ⅱ、使用CommonsMultipartResolver实现文件上传</h3>

<p>Spring内置了 <strong>CommonsMultipartResolver</strong> ，可以作为 StandardServletMultipartResolver 的替代方案，但是，由于使用的是Commons FileUpload的上传方式，需要引入jar支持：</p>

<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>最简单的配置方式就是其构造函数：</p>

<pre><code class="language-java">@Bean
public MultipartResolver multipartResolver() throws IOException
{
    return new CommonsMultipartResolver();
}
</code></pre>

<p>配置文件上传参数，与 StandardServletMultipartResolver 有所不同，CommonsMultipart-Resolver 不会强制要求设置临时文件路径。默认情况下，这个路径就是 Servlet 容器的临时目录。不过，通过设置 uploadTempDir 属性，我们可以将其指定为一个不同的位置</p>

<pre><code class="language-java">@Bean
public MultipartResolver multipartResolver() throws IOException
{
    CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver();
   //设置临时文件夹
    multipartResolver.setUploadTempDir(new FileSystemResource(&quot;C:\\Users\\xxx\\Desktop\\uploads&quot;));
    //设置最大内存大小
    multipartResolver.setMaxInMemorySize(100000);
    //设置上传文件的最大容量
    multipartResolver.setMaxUploadSize(2097152);
    return multipartResolver;
}
</code></pre>

<p>经测试，上传成功</p>

<p>注：如果没有引入上述两个jar包，会报文件找不到的错误：</p>

<pre><code class="language-properties">javax.servlet.ServletException: Servlet.init() for servlet dispatcher threw exception

Factory method 'multipartResolver' threw exception; nested exception is java.lang.NoClassDefFoundError: org/apache/commons/fileupload/FileItemFactory
</code></pre>

<h3 id="ⅲ-文件下载实现">Ⅲ、文件下载实现</h3>

<p>文件下载使用Spring提供的ResponseEntity实现</p>

<p>ResponseEntity：可以添加HttpStatus状态码的HttpEntity的扩展类。被用于RestTemplate和Controller层方法</p>

<p>①编写下载文件的controller方法：</p>

<pre><code class="language-java">@RequestMapping(&quot;/download&quot;)
public ResponseEntity&lt;byte[]&gt; filedownload(HttpServletRequest request, String filename) throws Exception{
     //此处指定只从桌面获取文件
     String path = &quot;C:\\Users\\xxx\\Desktop\\&quot;;
     File file = new File(path+File.separator+filename);

     //返回头部设置
     HttpHeaders headers = new HttpHeaders();
     headers.setContentDispositionFormData(&quot;attachment&quot;,filename);
    headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);

    //获取文件输入流
    InputStream is = new FileInputStream(file);

    //将文件转换成byte数组
    byte[] bytes = new byte[is.available()];
    is.read(bytes);

    //封装信息返回
    return new ResponseEntity&lt;byte[]&gt;(bytes,headers, HttpStatus.OK);
}
</code></pre>

<p>②编写JSP文件下载资源：</p>

<pre><code class="language-jsp">&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page isELIgnored=&quot;false&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;文件展示&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
文件名称：
&lt;c:out value=&quot;${fileName}&quot;&gt;&lt;/c:out&gt;&lt;br&gt;
文件大小：
&lt;c:out value=&quot;${fileSize}&quot;&gt;&lt;/c:out&gt;KB
&lt;a href=&quot;${pageContext.request.contextPath}/download?filename=${fileName}&quot;&gt;文件下载&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>页面展示如下，点击文件下载，弹出资源管理窗口，将其保存至目标路径
<figure><img src="/images/ring.svg" data-sizes="auto" data-src="/images/post_resource/spring-action/spring_action_07_04.jpg" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure>
下载完成</p>

<h2 id="三-处理异常">三、处理异常</h2>

<p>自定义异常在SpringMVC中是十分普遍的，有时候我们需要控制异常的输出样式，而不是赤裸裸的将错误信息展示在用户面前，那样并不友好，可能还有点辣眼睛</p>

<p>那么，SpringMVC中，怎么捕获异常并友好输出呢？也许你会想到使用try-catch的方式去处理，但是那样耦合性太强了，SpringMVC提供了两个注解进行捕捉处理</p>

<h3 id="ⅰ-exceptionhandler-myexception-class-捕捉异常">Ⅰ、@ExceptionHandler(MyException.class)捕捉异常</h3>

<p>@ExceptionHandler(）注解<strong>可以捕捉当前控制器内所有方法抛出的特定异常，而不需要在控制器内每个方法上去标识</strong></p>

<p>①编写自定义异常类，继承Exception</p>

<pre><code class="language-java">public class MyException extends Exception{
    public MyException() {
        super();
    }

    public MyException(String message) {
        super(message);
    }

    public MyException(String message, Throwable cause) {
        super(message, cause);
    }
}
</code></pre>

<p>②编写测试Controller</p>

<pre><code class="language-java">@Controller
public class ExceptionController {

    @ExceptionHandler(MyException.class)//捕捉当前控制器内任意方法抛出MyException
    public String toError(MyException myException, Model model){
        model.addAttribute(&quot;error&quot;,myException.getMessage());
        //返回指定的错误视图，经过特殊编写，会比浏览器默认错误页面更美观
        return &quot;error&quot;;
    }

    @RequestMapping(&quot;/exception&quot;)
    public String testException() throws MyException {
        //为了测试抛出异常，设置条件恒为true
        if(1==1){
            throw new MyException(&quot;系统搞错咯&quot;);
        }

        return &quot;123&quot;;
    }
}
</code></pre>

<p>③编写错误页面：error.jsp</p>

<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;%@ page isELIgnored=&quot;false&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;错误页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;您好，系统异常，请稍后重试&lt;/h1&gt;
    &lt;hr&gt;
    &lt;!--使用JSTL标签和EL表达式从modle获取错误信息--&gt;
    &lt;c:out value=&quot;${error}&quot;&gt;&lt;/c:out&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>测试结果：</p>

<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/images/post_resource/spring-action/spring_action_07_05.jpg" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure></p>

<h3 id="ⅱ-controlleradvice-为所有控制器处理异常">Ⅱ、@ControllerAdvice，为所有控制器处理异常</h3>

<p>即便如上述代码已经十分方便，我们仍有可能需要在每个有可能抛出异常的控制器内编写@ExceptionHandler(）注解方法，显然Spring可以做的更好。</p>

<p>@ControllerAdvice注解标注的类可以捕捉应用内所有的错误，并结合@ExceptionHandler(）在其内进行特殊处理，系统内抛出的所有错误，都会经过该类处理</p>

<p>①编写统一处理类</p>

<pre><code class="language-java">@ControllerAdvice
public class ExceptionHelper {
    //对特殊异常进行处理
    @ExceptionHandler(MyException.class)
    public String toError(MyException myException, Model model){
        model.addAttribute(&quot;error&quot;,myException.getMessage());
        return &quot;error&quot;;
    }
}
</code></pre>

<p>②普通controller方法</p>

<pre><code class="language-java">@Controller
public class ExceptionController {

    @RequestMapping(&quot;/exception&quot;)
    public String testException() throws MyException {
        //为了测试抛出异常，设置条件恒为true
        if(1==1){
            throw new MyException(&quot;系统搞错咯&quot;);
        }

        return &quot;123&quot;;
    }
}
</code></pre>

<p>测试结果：显然我们并没有在ExceptionController中对该错误进行显式处理，结果却跳转到错误页面，证明处理成功</p>

<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/images/post_resource/spring-action/spring_action_07_06.jpg" alt="" class="lazyload"><figcaption class="image-caption"></figcaption></figure></p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>GF.L </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://keep-zero.github.io/2019/spring_action07/>https://keep-zero.github.io/2019/spring_action07/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://keep-zero.github.io/tags/java/">
                    #java</a></span>
            
            <span class="tag"><a href="https://keep-zero.github.io/tags/spring/">
                    #spring</a></span>
            
            <span class="tag"><a href="https://keep-zero.github.io/tags/spring-action/">
                    #spring-action</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://keep-zero.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://keep-zero.github.io/2019/spring_action06/" class="prev" rel="prev" title="《Spring实战》-第六章:渲染视图（表达式，标签库，模板）"><i class="iconfont icon-left"></i>&nbsp;《Spring实战》-第六章:渲染视图（表达式，标签库，模板）</a>
         
        
        <a href="https://keep-zero.github.io/2019/spring_action09/" class="next" rel="next" title="《Spring实战》-第九章:Spring Web应用安全（Spring Security）">《Spring实战》-第九章:Spring Web应用安全（Spring Security）&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2011 - 2019</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
        </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://keep-zero.github.io">GF.L</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
		<span id="busuanzi_container_site_pv">
			本站访问量：<span id="busuanzi_value_site_pv"></span>次
		</span>
		&nbsp;
		<span id="busuanzi_container_site_uv">
			您是本站第 <span id="busuanzi_value_site_uv"></span> 位访问者
		</span>
    </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
