<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Keep Zero on Keep Zero</title>
    <link>https://keep-zero.github.io/</link>
    <description>Recent content in Keep Zero on Keep Zero</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 01 Sep 2019 14:38:02 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>《Spring实战》-第十四章：保护方法（Security）（2）-使用表达式增强方法保护</title>
      <link>https://keep-zero.github.io/2019/spring_action14_02/</link>
      <pubDate>Sun, 01 Sep 2019 14:38:02 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action14_02/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前一篇文章中，我们通过使用&lt;strong&gt;@Secured&lt;/strong&gt;和&lt;strong&gt;@RolesAllowed&lt;/strong&gt;两个注解实现了简单有效的基于角色的方法权限控制，但是有时候，我们并不是单纯的针对角色身份进行限制就可以的，还需要使用某些逻辑进行限制，所以Spring Security提供了四个注解帮助我们更细粒地去控制方法访问地权限，这些注解地参数都是SPEL表达式
&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_01.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用这几个注解之前，我们需要先将&lt;strong&gt;@EnableGlobalMethodSecurity()&lt;/strong&gt;的&lt;strong&gt;prePostEnabled&lt;/strong&gt;属性设置为&lt;strong&gt;true&lt;/strong&gt;，如同前述，也可以同时使用securedEnabled和jsr250Enabled&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先测试使用addUser接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
public User addUser(User user) {
    System.out.println(&amp;quot;添加用户&amp;quot;);
    return this.baseDao.save(user);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用dba登录，访问/user/userForm,访问用户信息填写页面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_02.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_03.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;提交表单，返回调用成功&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_04.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用@&lt;strong&gt;PreAuthorize&lt;/strong&gt;实现方法前校验，此处我们使用SPEL表达式限定addUser方法必须&lt;strong&gt;在访问者具备ROLE_ADMIN身份，且传入参数user的age属性值必须大于50的情况下才可以访问&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
@PreAuthorize(&amp;quot;hasRole(&#39;ROLE_ADMIN&#39;) AND #user.age&amp;gt;50&amp;quot;)
public User addUser(User user) {
System.out.println(&amp;quot;添加用户&amp;quot;);
return this.baseDao.save(user);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先使用dba用户进行访问，访问受限&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_05.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_06.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再使用admin进行访问，参数正确，允许访问：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_07.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;填写错误参数，年龄age填写为40，访问受限：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_08.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_09.jpg&#34; alt=&#34;&#34; /&gt;
 控制成功&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用@PostAuthorize实现方法后校验,为了方便校验，Spring Security在SPEL中提供了returnObject代表方法返回对象，此处我们限制&lt;strong&gt;仅当方法返回的结果的userName属性为“admin”时才可以放行&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
@PostAuthorize(&amp;quot;returnObject.userName==&#39;admin&#39;&amp;quot;)
public User addUser(User user) {
System.out.println(&amp;quot;添加用户&amp;quot;);
return this.baseDao.save(user);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先提交userName为dba的用户，访问受限&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_10.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_11.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;提交userName为admin的用户，允许访问&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_12.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_13.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用&lt;strong&gt;@PreFilter&lt;/strong&gt; 和&lt;strong&gt;@PostFilter&lt;/strong&gt;注解实现数据在执行方法前及执行方法后集合的过滤，Spring Scurity提供了&lt;strong&gt;filterObject对象指代目标拦截对象&lt;/strong&gt;，在&lt;strong&gt;@PreFilter&lt;/strong&gt;中使用时，其&lt;strong&gt;代表传入列表参数&lt;/strong&gt;，当传入参数中存在多个列表时，我们可以使用&lt;strong&gt;filterTarget&lt;/strong&gt;属性指定需要过滤的目标参数的名称；当在@PostFilter中使用时，其代表返回列表.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
@PostFilter(value=&amp;quot;filterObject.userName!=principal.username&amp;quot;)//限制返回的列表中，只允许返回和当前登陆用户名不同的user，即允许获取非当前用户
public List&amp;lt;User&amp;gt; getList() {
List&amp;lt;User&amp;gt; users = new ArrayList&amp;lt;&amp;gt;();
User user1 = new User(&amp;quot;admin&amp;quot;,&amp;quot;123456&amp;quot;,50);
User user2 = new User(&amp;quot;dba&amp;quot;,&amp;quot;123456&amp;quot;,51);
User user3 = new User(&amp;quot;common&amp;quot;,&amp;quot;123456&amp;quot;,52);
users.add(user1);
users.add(user2);
users.add(user3);
return users;
}

@Override
@PreFilter(filterTarget=&amp;quot;users&amp;quot;,value=&amp;quot;filterObject.userName==principal.username&amp;quot;)//限制进入方法的列表中，只能允许和当前登陆用户名一致的user传入，即只允许删除当前用户
public List&amp;lt;User&amp;gt; deleteList(List&amp;lt;User&amp;gt; users) {
return users;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;编写controller&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(value = {&amp;quot;/user/deleteUsers&amp;quot;})
public ModelAndView deleteUsers(){
    ModelAndView model = new ModelAndView();
    List&amp;lt;User&amp;gt; users = new ArrayList&amp;lt;&amp;gt;();
    User user1 = new User(&amp;quot;admin&amp;quot;,&amp;quot;123456&amp;quot;,50);
    User user2 = new User(&amp;quot;dba&amp;quot;,&amp;quot;123456&amp;quot;,50);
    User user3 = new User(&amp;quot;common&amp;quot;,&amp;quot;123456&amp;quot;,50);
    users.add(user1);
    users.add(user2);
    users.add(user3);
    List&amp;lt;User&amp;gt; targetList = this.baseService.deleteList(users);
    model.addObject(&amp;quot;message&amp;quot;,&amp;quot;您删除的用户：&amp;quot;);
    model.addObject(&amp;quot;users&amp;quot;,targetList);
    model.setViewName(&amp;quot;showUserList&amp;quot;);
    return model;
}

@RequestMapping(value = {&amp;quot;/user/getUsers&amp;quot;})
public ModelAndView getUsers(){
    ModelAndView model = new ModelAndView();
    List&amp;lt;User&amp;gt; users = this.baseService.getList();
    model.addObject(&amp;quot;message&amp;quot;,&amp;quot;您获取到的用户&amp;quot;);
    model.addObject(&amp;quot;users&amp;quot;,users);
    model.setViewName(&amp;quot;showUserList&amp;quot;);
    return model;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写视图：showUserList.jsp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
&amp;lt;%@ page isELIgnored=&amp;quot;false&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;用户信息列表&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h2&amp;gt;${message}&amp;lt;/h2&amp;gt;

    &amp;lt;table style=&amp;quot;border:1px solid orangered;&amp;quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;用户名&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;用户密码&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;用户年龄&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;c:forEach items=&amp;quot;${users}&amp;quot; var=&amp;quot;user&amp;quot;&amp;gt;
            &amp;lt;tr&amp;gt;
                &amp;lt;td style=&amp;quot;font-size: large&amp;quot;&amp;gt;${user.userName}&amp;lt;/td&amp;gt;
                &amp;lt;td style=&amp;quot;font-size: large&amp;quot;&amp;gt;${user.password}&amp;lt;/td&amp;gt;
                &amp;lt;td style=&amp;quot;font-size: large&amp;quot;&amp;gt;${user.age}&amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
        &amp;lt;/c:forEach&amp;gt;
    &amp;lt;/table&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用admin访问/user/getUsers,结果获取到非admin用户信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_14.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用dba访问/user/getUsers,结果获取到非dba用户信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_15.jpg&#34; alt=&#34;&#34; /&gt;
使用admin访问/user/deleteUsers，结果仅删除了自身&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_02_16.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第十四章：保护方法（Security）（1）-使用注解保护方法</title>
      <link>https://keep-zero.github.io/2019/spring_action14_01/</link>
      <pubDate>Sun, 01 Sep 2019 11:53:04 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action14_01/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;尽管Spring Security为我们提供了Web层的安全保护，我们依旧有可能会疏忽而导致用户通过正常访问路径访问到不应该访问的方法，所以除了在web层实施保护以外，我们还需要给底层的方法施加保护层。这样就能保证如果用户不具备权限的话，就无法执行相应的逻辑&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Spring Security 提供了三种不同的安全注解：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Spring Security 自带的 &lt;strong&gt;@Secured&lt;/strong&gt; 注解；&lt;/li&gt;
&lt;li&gt;JSR-250 的 &lt;strong&gt;@RolesAllowed&lt;/strong&gt; 注解；&lt;/li&gt;
&lt;li&gt;表达式驱动的注解，包括 &lt;strong&gt;@PreAuthorize 、 @PostAuthorize 、 @PreFilter 和 @PostFilter&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中，&lt;strong&gt;@Secured&lt;/strong&gt; 和 &lt;strong&gt;@RolesAllowed&lt;/strong&gt; 方案非常类似，能够基于用户所授予的权限限制对方法的访问&lt;/p&gt;

&lt;p&gt;基础环境：(详细配置解释请参考第九章文章)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;!--定义spring版本信息--&amp;gt;
&amp;lt;properties&amp;gt;
    &amp;lt;org.springframework.version&amp;gt;5.1.3.RELEASE&amp;lt;/org.springframework.version&amp;gt;
    &amp;lt;spring.security.version&amp;gt;5.1.3.RELEASE&amp;lt;/spring.security.version&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- servlet --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- jstl --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;jstl&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--lombok引入，用于精简代码，bean类使用注解默认携带setter和getter方法等--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.18.4&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--    Spring基础框架引入   --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-aop&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.8.13&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- Spring MVC --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--     Spring Security依赖       --&amp;gt;
    &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-core --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-security-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.security.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-web --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-security-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.security.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-com.my.spring.config --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-security-config&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.security.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;配置web环境&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;配置SpringMVC默认&lt;strong&gt;DispatcherServlet&lt;/strong&gt;类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

private final Logger logger = LoggerFactory.getLogger(this.getClass());

/*AbstractAnnotationConfigDispatcherServletInitializer 会同时创
建 DispatcherServlet 和 ContextLoaderListener 。 GetServlet-ConfigClasses() 方法返回的带有 @Configuration 注解的
类将会用来定义 DispatcherServlet 应用上下文中的 bean 。 getRootConfigClasses() 方法返回的带有 @Configuration 注解的类将
会用来配置 ContextLoaderListener 创建的应用上下文中的 bean 。*/

@Override
protected Class&amp;lt;?&amp;gt;[] getRootConfigClasses() {
    return new Class[]{RootConfig.class};
}

@Override
protected Class&amp;lt;?&amp;gt;[] getServletConfigClasses() {
    return new Class[]{WebConfig.class};
}

@Override
protected String[] getServletMappings() {
    logger.debug(&amp;quot;DispatcherServlet获取匹配的前端控制器。。。。。。&amp;quot;);
    return new String[]{&amp;quot;/&amp;quot;};
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建Spring Security的&lt;strong&gt;DelegatingFilterProxy&lt;/strong&gt;,自动加载&lt;strong&gt;springSecurityFilterChain&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
*  拦截发往应用中的请求，并将请求委托给 ID 为 springSecurityFilterChain的bean
*  springSecurityFilterChain 本身是另一个特殊的 Filter,它也被称为 FilterChainProxy.它可以链接任意一个或多个其他的 Filter。
*  Spring Security 依赖一系列 Servlet Filter 来提供不同的安全特性。
**/
public class SpringSecurityInitializer extends AbstractSecurityWebApplicationInitializer {}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置SpringMVC的根配置和Web配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(basePackages ={&amp;quot;com.my.spring&amp;quot;},excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION,value = {EnableWebMvc.class})})
public class RootConfig {
}

@EnableWebMvc
@Configuration
@ComponentScan(basePackages = {&amp;quot;com.my.spring.controller&amp;quot;})
@Import(SecurityConfig.class)//引入Spring Security的配置
public class WebConfig extends WebMvcConfigurationSupport {

/**
 * 定义一个视图解析器
 *
 * @return org.springframework.web.servlet.ViewResolver
 *
 * @author lai.guanfu 2019/3/5
 * @version 1.0
 **/
@Bean
public ViewResolver viewResolver(){
    InternalResourceViewResolver resourceViewResolver = new InternalResourceViewResolver();
    resourceViewResolver.setPrefix(&amp;quot;/WEB-INF/view/&amp;quot;);
    resourceViewResolver.setSuffix(&amp;quot;.jsp&amp;quot;);
    resourceViewResolver.setExposeContextBeansAsAttributes(true);
    resourceViewResolver.setViewClass(JstlView.class);
    return resourceViewResolver;
}

@Override
protected void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
    configurer.enable();
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SecurityConfig.java:开启Spring Security并配置基本拦截和用户信息,增加两个用户&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableWebSecurity//启用Spring Security
public class SecurityConfig extends WebSecurityConfigurerAdapter {

/**
 * 设置拦截路径
 * @param http
 * @throws Exception
 */
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
            //配置拦截路径以及认证通过的身份，此处指定访问/user/**的请求会被拦截认证，必须以DBA或者ADMIN的身份登录
            .antMatchers(&amp;quot;/user/**&amp;quot;).access(&amp;quot;hasAnyRole(&#39;ROLE_DBA&#39;,&#39;ROLE_ADMIN&#39;)&amp;quot;)
            //表明除了上述路径需要拦截认证外，其余路径全部不进行认证
            .anyRequest().permitAll()
            //add()方法用于连接各种配置指令
            .and() 
            //当重写configure(HttpSecurity http)方法后，将失去Spring Security的默认登录页，可以使用formLogin()重新启用
            .formLogin();
}

/**
 * 使用内存设置基本人物信息
 * @param auth
 * @throws Exception
 */
@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
    //使用内存添加用户名及登陆密码和身份，使用指定编码器对密码进行编码
    auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(&amp;quot;admin&amp;quot;).password(new BCryptPasswordEncoder().encode(&amp;quot;123456&amp;quot;)).roles(&amp;quot;ADMIN&amp;quot;);
    auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(&amp;quot;dba&amp;quot;).password(new BCryptPasswordEncoder().encode(&amp;quot;123456&amp;quot;)).roles(&amp;quot;DBA&amp;quot;);

    //Spring Security 5.0之前的写法，5.0之后，如果没有指定密码编码器，将会报There is no PasswordEncoder mapped for the id &amp;quot;null&amp;quot;的错
    /*auth.inMemoryAuthentication().withUser(&amp;quot;admin&amp;quot;).password(&amp;quot;123456&amp;quot;).roles(&amp;quot;ADMIN&amp;quot;);
    auth.inMemoryAuthentication().withUser(&amp;quot;dba&amp;quot;).password(&amp;quot;123456&amp;quot;).roles(&amp;quot;DBA&amp;quot;);*/
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编写基本类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data//lombok注解，默认编译生成setter和getter方法
public class User {
/**
 * 用户名
 **/
private String userName;

/**
 * 密码
 **/
private String password;

/**
 * 年龄
 **/
private Integer age;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编写基本dao，此处为方便起见，不实现jdbc&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class BaseDao {

/**
 * 根据用户名获取用户
 * @param userName
 * @return
 */
public User get(String userName) {
    System.out.println(&amp;quot;获取用户&amp;quot;);
    User user = new User();
    user.setUserName(userName);
    return user;
}

/**
 * 根据用户名删除用户
 * @return
 */
public void delete() {
    System.out.println(&amp;quot;删除用户！！！&amp;quot;);
}

/**
 * 保存用户
 * @param user
 * @return
 */
public User save(User user) {
    return user;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编写基本Service接口和实现类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BaseService {

/**
 * 获取管理员信息
 * @return
 */
User getAdmin();

/**
 * 获取DBA用户信息
 * @return
 */
User getDBA();

/**
 * 删除用户
 */
void deleteUser();

/**
 * 添加用户
 * @param user
 * @return
 */
User addUser(User user);
}

@Component
public class BaseServiceImpl implements BaseService {

@Autowired
private BaseDao baseDao;

@Override
public User getAdmin() {
    return this.baseDao.get(&amp;quot;admin&amp;quot;);
}

@Override
public User getDBA() {
    return this.baseDao.get(&amp;quot;dba&amp;quot;);
}

@Override
public void deleteUser() {
    this.baseDao.delete();
}

@Override
public User addUser(User user) {
    return this.baseDao.save(user);
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编写基本controller&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class MyController{

@Autowired
private BaseService baseService;

@RequestMapping(value = {&amp;quot;/user/getAdmin&amp;quot;},method = RequestMethod.GET)
public ModelAndView getAdmin(){
    ModelAndView model = new ModelAndView();
    User admin = this.baseService.getAdmin();
    model.addObject(&amp;quot;user&amp;quot;,admin);
    model.setViewName(&amp;quot;showUserMessage&amp;quot;);
    return model;
}

@RequestMapping(value = {&amp;quot;/user/getDBA&amp;quot;},method = RequestMethod.GET)
public ModelAndView getDBA(){
    ModelAndView model = new ModelAndView();
    User dba = this.baseService.getDBA();
    model.addObject(&amp;quot;user&amp;quot;,dba);
    model.setViewName(&amp;quot;showUserMessage&amp;quot;);
    return model;
}

@RequestMapping(&amp;quot;/user/userForm&amp;quot;)
public String login(){
    return &amp;quot;userForm&amp;quot;;
}

@RequestMapping(value = {&amp;quot;/user/addUser&amp;quot;})
public ModelAndView addUser(User user){
    ModelAndView model = new ModelAndView();
    User temp = this.baseService.addUser(user);
    model.addObject(&amp;quot;user&amp;quot;,temp);
    model.setViewName(&amp;quot;showUserMessage&amp;quot;);
    return model;
}

@RequestMapping(value = {&amp;quot;/user/deleteUser&amp;quot;})
public ModelAndView deleteUser(){
    ModelAndView model = new ModelAndView();
    this.baseService.deleteUser();
    model.addObject(&amp;quot;message&amp;quot;,&amp;quot;删除成功！！！&amp;quot;);
    model.setViewName(&amp;quot;showUserMessage&amp;quot;);
    return model;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编写基本视图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/userForm.jsp

&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;新增用户&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form method=&amp;quot;get&amp;quot; action=&amp;quot;./user/addUser&amp;quot;&amp;gt;
    &amp;lt;label&amp;gt;用户名：&amp;lt;/label&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;userName&amp;quot;&amp;gt;
    &amp;lt;label&amp;gt;密码：&amp;lt;/label&amp;gt;&amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot;&amp;gt;
    &amp;lt;label&amp;gt;年龄：&amp;lt;/label&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;age&amp;quot;&amp;gt;
    &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;提交&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

/showUserMessage.jsp
&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
&amp;lt;%@ page isELIgnored=&amp;quot;false&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;用户信息页&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;c:if test=&amp;quot;${user != null}&amp;quot;&amp;gt;
&amp;lt;label&amp;gt;您获取到的用户名字为：&amp;lt;/label&amp;gt;&amp;lt;span style=&amp;quot;font-size: large&amp;quot;&amp;gt;${user.userName}&amp;lt;/span&amp;gt;
&amp;lt;/c:if&amp;gt;
&amp;lt;c:if test=&amp;quot;${user == null}&amp;quot;&amp;gt;
&amp;lt;span&amp;gt;${message}&amp;lt;/span&amp;gt;
&amp;lt;/c:if&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其基本目录结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_01.jpg&#34; alt=&#34;&#34; /&gt;
执行简单测试：&lt;/p&gt;

&lt;p&gt;访问/user/getAdmin,使用dba进行登录&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_02.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_03.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;访问/user/getDBA，使用admin进行登录&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_04.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_05.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，无论是amdin还是dba用户，只要具备/user/**的访问权限，就可以对路径内的方法拥有畅通的访问，这显然不是我们所允许的。&lt;/p&gt;

&lt;h2 id=&#34;ⅰ-secured注解实现方法访问权限限制&#34;&gt;&lt;strong&gt;Ⅰ、@Secured注解实现方法访问权限限制&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;要使用&lt;strong&gt;@Secured&lt;/strong&gt;之前，我们需要先开启Security的方法权限配置：&lt;strong&gt;@EnableGlobalMethodSecurity(securedEnabled = true)&amp;amp;GlobalMethodSecurityConfiguration&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果 securedEnabled 属性的值为 true 的话，将会创建一个切点，这样的话 Spring Security 切面就会包装带有 @Secured 注解的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableGlobalMethodSecurity(securedEnabled = true)//开启全局方法权限控制
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，为Service添加方法权限控制-&lt;strong&gt;@Secured(value = {})&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@Secured&lt;/strong&gt; 注解会使用一个 String 数组作为参数。每个 String 值是一个权限，调用这个方法至少需要具备其中的一个权限：&lt;/p&gt;

&lt;p&gt;如下面的getAdmin方法只允许具备ROLE_ADMIN身份的用户访问，也就是admin&lt;/p&gt;

&lt;p&gt;而getDBA方法则允许具备ROLE_ADMIN或者ROLE_DBA身份的用户访问，依此类推&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class BaseServiceImpl implements BaseService {

    @Autowired
    private BaseDao baseDao;

    @Override
    @Secured(value = {&amp;quot;ROLE_ADMIN&amp;quot;})
    public User getAdmin() {
        return this.baseDao.get(&amp;quot;admin&amp;quot;);
    }

    @Override
    @Secured(value = {&amp;quot;ROLE_ADMIN&amp;quot;,&amp;quot;ROLE_DBA&amp;quot;})
    public User getDBA() {
        return this.baseDao.get(&amp;quot;dba&amp;quot;);
    }

    @Override
    @Secured(value = {&amp;quot;ROLE_ADMIN&amp;quot;})
    public void deleteUser() {
        this.baseDao.delete();
    }

    @Override
    @Secured(value = {&amp;quot;ROLE_ADMIN&amp;quot;,&amp;quot;ROLE_DBA&amp;quot;})
    public User addUser(User user) {
        return this.baseDao.save(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;p&gt;使用admin身份访问/user/getAdmin，允许访问&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_06.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_07.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用admin身份访问/user/deleteUser，允许访问&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_08.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用dba身份访问/user/getAdmin,权限不足&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_09.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_10.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用dba身份访问/user/deleteUser,权限不足&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_11.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，即便dba拥有对/user/**路径的完全访问权限，依旧无法访问受限方法，方法保护成功&lt;/p&gt;

&lt;h2 id=&#34;ⅱ-rolesallowed-注解实现方法访问权限限制&#34;&gt;Ⅱ、 @RolesAllowed 注解实现方法访问权限限制&lt;/h2&gt;

&lt;p&gt;@&lt;strong&gt;RolesAllowed&lt;/strong&gt; 注解和 @Secured 注解在各个方面基本上都是一致的。唯一显著的区别在于 @RolesAllowed 是 JSR-250 定义的 Java 标准注解&lt;/p&gt;

&lt;p&gt;两者使用上的区别在于注解名称和@EnableGlobalMethodSecurity()开启的方式&lt;/p&gt;

&lt;p&gt;①引入maven依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.annotation&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jsr250-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②更改&lt;strong&gt;MethodSecurityConfig&lt;/strong&gt;，开启jsr250Enabled 支持，值得注意的是，此处实际上可以同时使用securedEnabled和jsr250Enabled，两者并不冲突&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableGlobalMethodSecurity(jsr250Enabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③更改目标方法使用的注解&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class BaseServiceImpl implements BaseService {

    @Autowired
    private BaseDao baseDao;

    @Override
    @RolesAllowed(value = {&amp;quot;ROLE_ADMIN&amp;quot;})
    public User getAdmin() {
        return this.baseDao.get(&amp;quot;admin&amp;quot;);
    }

    @Override
    @RolesAllowed(value = {&amp;quot;ROLE_ADMIN&amp;quot;,&amp;quot;ROLE_DBA&amp;quot;})
    public User getDBA() {
        return this.baseDao.get(&amp;quot;dba&amp;quot;);
    }

    @Override
    @RolesAllowed(value = {&amp;quot;ROLE_ADMIN&amp;quot;})
    public void deleteUser() {
        this.baseDao.delete();
    }

    @Override
    @RolesAllowed(value = {&amp;quot;ROLE_ADMIN&amp;quot;,&amp;quot;ROLE_DBA&amp;quot;})
    public User addUser(User user) {
        return this.baseDao.save(user);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;④执行测试&lt;/p&gt;

&lt;p&gt;使用admin登录，访问/user/getAdmin，允许访问&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_12.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用admin登录，访问/user/deleteUser，允许访问&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_13.jpg&#34; alt=&#34;&#34; /&gt;
使用dba登录，访问/user/getAdmin，访问受限&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_14.jpg&#34; alt=&#34;&#34; /&gt;
使用dba登录，访问/user/deleteUser，访问受限&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_14_01_15.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第十三章：缓存数据（2）-在方法上使用缓存</title>
      <link>https://keep-zero.github.io/2019/spring_action13_02/</link>
      <pubDate>Sun, 01 Sep 2019 11:52:59 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action13_02/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Spring 的缓存抽象在很大程度上是围绕切面构建的。在 Spring 中启用缓存时，会创建一个切面，它触发一个或更多的 Spring 的缓存注解，Spring提供的缓存注解主要有以下几个：
&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_13_02_01.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ⅰ-填充缓存&#34;&gt;Ⅰ、填充缓存&lt;/h2&gt;

&lt;p&gt;由上述注解可知，&lt;strong&gt;@Cacheable&lt;/strong&gt;和&lt;strong&gt;@CachePut&lt;/strong&gt;注解可以往缓存填充内容，两者的共有属性有：
&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_13_02_02.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在最简单的情况下，在 @Cacheable 和 @CachePut 的这些属性中，只需使用 value 属性指定一个或多个缓存即可&lt;/p&gt;

&lt;p&gt;上一篇文章中我们介绍了Spring整合Redis的过程，我们依旧使用Redis缓存了解Spring对缓存的抽象&lt;/p&gt;

&lt;p&gt;我们事先编写一个BaseDao作为操作基准&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class BaseDao {

    /**
     * 根据id获取信息
     **/
    @Cacheable(value = &amp;quot;myCache&amp;quot;)
    public String findOne(Integer id){
        System.out.println(&amp;quot;执行findOne方法。。。。&amp;quot;);
        return &amp;quot;我是BaseDao&amp;quot;+id;
    }

    /**
     * 根据id更改信息
     **/
    @CachePut(value = &amp;quot;myCache&amp;quot;)
    public String save(Integer id){
        System.out.println(&amp;quot;执行save方法。。。。。&amp;quot;);
        return &amp;quot;BaseDao&amp;quot;+id;
    }

    /**
     * 根据id移除信息
     **/
    @CacheEvict(value = &amp;quot;myCache&amp;quot;)
    public void remove(Integer id){
        System.out.println(&amp;quot;执行remove方法。。。。。&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写测试类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = {RedisCacheConfig.class})
public class AppTest {
    @Autowired
    private BaseDao baseDao;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;测试使用-cacheable存取数据&#34;&gt;&lt;strong&gt;测试使用@Cacheable存取数据&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;我们知道当缓存中没有对应数据的时候，会执行使用了@Cacheable注解的方法，并将结果存入缓存&lt;/p&gt;

&lt;p&gt;如果缓存中已经存在对应数据，则直接将缓存数据返回：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testCacheAble(){
    System.out.println(this.baseDao.findOne(0));
    System.out.println(this.baseDao.findOne(0));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此处执行两次findOne（0），测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;执行findOne方法。。。。
我是BaseDao0
我是BaseDao0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，此处只是实际上只有一次真正进入了findOne方法内，第二次从缓存中获取数据，以下是redis-cli中看到的结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_13_02_03.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在缓存中，缓存的key值默认为 &lt;strong&gt;缓存名称::传参值&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;测试使用-cacheput更新数据&#34;&gt;测试使用@CachePut更新数据&lt;/h3&gt;

&lt;p&gt;由于使用@CachePut注解&lt;strong&gt;默认每次都会进入方法并使用返回值更新缓存&lt;/strong&gt;，所以该注解在实际业务中一般用在更新数据的方法上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testCachePut(){
    this.baseDao.save(0);
    this.baseDao.save(0);
    System.out.println(this.baseDao.findOne(0));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;执行save方法。。。。。
执行save方法。。。。。
BaseDao0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，此处两次执行save方法都进入了，执行save之后再调用findOne方法，依旧直接从缓存取值，&lt;strong&gt;缓存已更新&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_13_02_04.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;自定义缓存的key&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@Cacheable&lt;/strong&gt; 和 &lt;strong&gt;@CachePut&lt;/strong&gt; 都有一个名为 key 属性，这个属性能够替换默认的 key ，它是通过一个 SpEL 表达式计算得到的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_13_02_05.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如将上述findOne()和save()方法缓存的key定义为BaseDao的class&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Cacheable(value = &amp;quot;myCache&amp;quot;,key = &amp;quot;#root.targetClass&amp;quot;)
public String findOne(Integer id){
    System.out.println(&amp;quot;执行findOne方法。。。。&amp;quot;);
    return &amp;quot;我是BaseDao&amp;quot;+id;
}

@CachePut(value = &amp;quot;myCache&amp;quot;,key = &amp;quot;#root.targetClass&amp;quot;)
public String save(Integer id){
    System.out.println(&amp;quot;执行save方法。。。。。&amp;quot;);
    return &amp;quot;BaseDao&amp;quot;+id;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次执行测试testCacheAble（）方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;执行findOne方法。。。。
我是BaseDao0
我是BaseDao0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到缓存如下：使用class com.my.spring.dao.BaseDao作为缓存的key&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_13_02_06.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ⅱ-移除缓存&#34;&gt;Ⅱ、移除缓存&lt;/h2&gt;

&lt;h3 id=&#34;使用-cacheevict测试移除缓存&#34;&gt;使用@CacheEvict测试移除缓存&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
public void testCacheEvict(){
    this.baseDao.remove(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;执行remove方法。。。。。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缓存已经清除:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_13_02_07.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此时再去访问findOne(),结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;执行findOne方法。。。。
我是BaseDao0
我是BaseDao0
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第十三章：缓存数据（1）-Spring对缓存的支持</title>
      <link>https://keep-zero.github.io/2019/spring_action13_01/</link>
      <pubDate>Sun, 01 Sep 2019 11:52:45 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action13_01/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓存（ Caching ）&lt;/strong&gt;可以存储经常会用到的信息，这样每次需要的时候，这些信息都是立即可用的。我们将会了解到 Spring 的缓存抽象。尽管 Spring 自身并没有实现缓存解决方案，但是它对缓存功能提供了声明式的支持，能够与多种流行的缓存实现进行集成&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;ⅰ-开启缓存支持&#34;&gt;Ⅰ、开启缓存支持&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;注解开启：&lt;strong&gt;@EnableCaching&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;配置开启： &lt;strong&gt;&lt;a href=&#34;cache:annotation-driven&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;cache:annotation-driven&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两种开启方法的工作方式是相同的。它们都会创建一个&lt;strong&gt;切面（ aspect ）&lt;/strong&gt;并触发Spring 缓存注解的&lt;strong&gt;切点（ pointcut ）&lt;/strong&gt;。根据所使用的注解以及缓存的状态，这个切面会从缓存中获取数据，将数据添加到缓存之中或者从缓存中移除某个值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.springframework.cache.annotation.EnableCaching;
@Configuration
@EnableCaching
public class CacheConfig {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:cache=&amp;quot;http://www.springframework.org/schema/cache&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd&amp;quot;&amp;gt;
     &amp;lt;!--启用缓存注解功能，这个是必须的，否则注解不会生效--&amp;gt;
     &amp;lt;!--有一个cache-manager属性用来指定当前所使用的CacheManager对应的bean的名称，默认是cacheManager--&amp;gt;
     &amp;lt;cache:annotation-driven/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ⅱ-配置缓存管理器&#34;&gt;Ⅱ、配置缓存管理器&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;缓存管理器&lt;/strong&gt;：是 Spring 缓存抽象的&lt;strong&gt;核心&lt;/strong&gt;，它能够与多个流行的缓存实现进行集成&lt;/p&gt;

&lt;p&gt;Spring内置了多个缓存管理器：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SimpleCacheManager&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NoOpCacheManager&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ConcurrentMapCacheManager&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;mdash;-默认使用的缓存管理器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CompositeCacheManager&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EhCacheCacheManager&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-较常用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RedisCacheManager&lt;/strong&gt; （来自于 &lt;strong&gt;Spring Data Redis&lt;/strong&gt; 项目）&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;较常用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GemfireCacheManager&lt;/strong&gt; （来自于 &lt;strong&gt;Spring Data GemFire&lt;/strong&gt; 项目）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-配置concurrentmapcachemanager&#34;&gt;1、配置ConcurrentMapCacheManager&lt;/h3&gt;

&lt;p&gt;①注解配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@EnableCaching
public class ConcurrentMapCacheConfig {
    @Bean
    public CacheManager cacheManager1(){
        return new ConcurrentMapCacheManager();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②XML配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:cache=&amp;quot;http://www.springframework.org/schema/cache&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd&amp;quot;&amp;gt;
    &amp;lt;cache:annotation-driven/&amp;gt;
    &amp;lt;!--定义缓存管理器--&amp;gt;
    &amp;lt;bean id=&amp;quot;cacheManager&amp;quot; class=&amp;quot;org.springframework.cache.concurrent.ConcurrentMapCacheManager&amp;quot;&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-配置ehcachecachemanager&#34;&gt;2、配置EhCacheCacheManager&lt;/h3&gt;

&lt;p&gt;EhCache 是一个&lt;strong&gt;纯Java的进程内缓存框架&lt;/strong&gt;，具有快速、精干等特点，是Hibernate中默认的CacheProvider&lt;/p&gt;

&lt;p&gt;缓存数据有三级：&lt;strong&gt;内存、堆外缓存Off-Heap、Disk缓存&lt;/strong&gt;，因此无需担心容量问题。还可以通过RMI、可插入API等方式进行分布式缓存。&lt;/p&gt;

&lt;p&gt;缓存数据会在虚拟机重启的过程中写入磁盘，持久化。&lt;/p&gt;

&lt;p&gt;具有缓存和缓存管理器的侦听接口。&lt;/p&gt;

&lt;p&gt;支持多缓存管理器实例，以及一个实例的多个缓存区域。&lt;/p&gt;

&lt;p&gt;由于Spring只是提供了基本的管理器接口，还需要依赖于ehcache的第三方cache实现管理&lt;/p&gt;

&lt;p&gt;引入依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- 引入Spring对cache的支持 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-context-support&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- 引入ecache支持 --&amp;gt;
&amp;lt;!-- https://mvnrepository.com/artifact/net.sf.ehcache/ehcache --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;net.sf.ehcache&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;ehcache&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.10.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;①注解配置，此处使用的CacheManager是ehcache的缓存管理器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import net.sf.ehcache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.ehcache.EhCacheCacheManager;
import org.springframework.cache.ehcache.EhCacheManagerFactoryBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;

@Configuration
@EnableCaching
public class EhCacheConfig {
    /**
     * 定义缓存管理器，EhCacheCacheManager是Spring提供的管理器支持，需要将ecache的缓存管理器注入到EhCacheCacheManager中
     **/
    @Bean
    public EhCacheCacheManager cacheManager2(CacheManager cm){
        return new EhCacheCacheManager(cm);
    }

    /**
     * 定义缓存管理器工厂，用于生产EhCacheManager
     **/
    @Bean
    public EhCacheManagerFactoryBean ehCacheManagerFactoryBean(){
        EhCacheManagerFactoryBean factoryBean = new EhCacheManagerFactoryBean();
        factoryBean.setConfigLocation(new ClassPathResource(&amp;quot;ehcache.xml&amp;quot;));
        return factoryBean;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②XML配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:cache=&amp;quot;http://www.springframework.org/schema/cache&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd&amp;quot;&amp;gt;
    &amp;lt;cache:annotation-driven/&amp;gt;

    &amp;lt;!--定义缓存管理器--&amp;gt;
    &amp;lt;bean id=&amp;quot;cacheManager&amp;quot; class=&amp;quot;org.springframework.cache.ehcache.EhCacheCacheManager&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;cacheManager&amp;quot; ref=&amp;quot;ehcache&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
   &amp;lt;/bean&amp;gt;

    &amp;lt;!--定义缓存管理器工厂--&amp;gt;
    &amp;lt;bean id=&amp;quot;ehcache&amp;quot; class=&amp;quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;configLocation&amp;quot; value=&amp;quot;classpath*:ehcache.xml&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，ehcache.xml配置文件简单配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;ehcache&amp;gt;
    &amp;lt;diskStore path=&amp;quot;java.io.tmpdir&amp;quot;/&amp;gt;
    &amp;lt;!--
        maxElementsOnDisk：磁盘缓存中最多可以存放的元素数量,0表示无穷大  
        maxElementsInMemory：内存缓存中最多可以存放的元素数量,若放入Cache中的元素超过这个数值,则有以下两种情况  
                             1)若overflowToDisk=true,则会将Cache中多出的元素放入磁盘文件中  
                             2)若overflowToDisk=false,则根据memoryStoreEvictionPolicy策略替换Cache中原有的元素  
         eternal：缓存中对象是否永久有效,即是否永驻内存,true时将忽略timeToIdleSeconds和timeToLiveSeconds
         timeToIdleSeconds:缓存数据在失效前的允许闲置时间(单位:秒),仅当eternal=false时使用,默认值是0表示可闲置时间无穷大,此为可选属性  
                             即访问这个cache中元素的最大间隔时间,若超过这个时间没有访问此Cache中的某个元素,那么此元素将被从Cache中清除  
        timeToLiveSeconds:缓存数据在失效前的允许存活时间(单位:秒),仅当eternal=false时使用,默认值是0表示可存活时间无穷大  
                             即Cache中的某元素从创建到清楚的生存时间,也就是说从创建开始计时,当超过这个时间时,此元素将从Cache中清除
        overflowToDisk:内存不足时,是否启用磁盘缓存(即内存中对象数量达到maxElementsInMemory时,Ehcache会将对象写到磁盘中)  
                             会根据标签中path值查找对应的属性值,写入磁盘的文件会放在path文件夹下,文件的名称是cache的名称,后缀名是data  
        diskPersistent:是否持久化磁盘缓存,当这个属性的值为true时,系统在初始化时会在磁盘中查找文件名为cache名称,后缀名为index的文件  
                             这个文件中存放了已经持久化在磁盘中的cache的index,找到后会把cache加载到内存  
                             要想把cache真正持久化到磁盘,写程序时注意执行net.sf.ehcache.Cache.put(Element element)后要调用flush()方法
    --&amp;gt;
    &amp;lt;defaultCache
            maxElementsInMemory=&amp;quot;1000&amp;quot;
            eternal=&amp;quot;false&amp;quot;
            timeToIdleSeconds=&amp;quot;120&amp;quot;
            timeToLiveSeconds=&amp;quot;120&amp;quot;
            overflowToDisk=&amp;quot;false&amp;quot;/&amp;gt;
    &amp;lt;!--定义一个缓存--&amp;gt;
    &amp;lt;cache name=&amp;quot;ehCache&amp;quot;
           maxElementsOnDisk=&amp;quot;20000&amp;quot;
           maxElementsInMemory=&amp;quot;2000&amp;quot;
           eternal=&amp;quot;false&amp;quot;
           overflowToDisk=&amp;quot;true&amp;quot;
           diskPersistent=&amp;quot;true&amp;quot;/&amp;gt;

&amp;lt;/ehcache&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-配置rediscachemanager&#34;&gt;3、配置RedisCacheManager&lt;/h3&gt;

&lt;p&gt;Redis 可以用来为 Spring 缓存抽象机制存储缓存条目， Spring Data Redis 提供了 RedisCacheManager ，这是 CacheManager 的一个实现。&lt;/p&gt;

&lt;p&gt;RedisCacheManager 会与一个 Redis 服务器协作，并通过 RedisTemplate 将缓存条目存储到 Redis 中&lt;/p&gt;

&lt;p&gt;上一节已经了解过Redis，此处我们需要先引入Redis支持：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--引入Spring Data Redis--&amp;gt;
&amp;lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.data&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-data-redis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.5.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--引入jedis支持--&amp;gt;
&amp;lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.9.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;①混合配置&lt;/p&gt;

&lt;p&gt;application-redis.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; 
       xmlns:cache=&amp;quot;http://www.springframework.org/schema/cache&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;
    &amp;lt;cache:annotation-driven cache-manager=&amp;quot;redisCacheManager&amp;quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RedisConfig.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(basePackages = {&amp;quot;com.my.spring.dao&amp;quot;})
@ImportResource(&amp;quot;classpath:application-redis.xml&amp;quot;)//引入配置文件
@EnableCaching
public class RedisCacheConfig {

    /**
     * 定义缓存管理器，注入redisConnectionFactory
     * @param redisConnectionFactory
     * @return
     */
    @Bean(&amp;quot;redisCacheManager&amp;quot;)
    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory){
        RedisCacheManager.RedisCacheManagerBuilder builder = 
                    RedisCacheManager.RedisCacheManagerBuilder.fromConnectionFactory(redisConnectionFactory);
        Set&amp;lt;String&amp;gt; cacheNames = new HashSet&amp;lt;String&amp;gt;() {{
            add(&amp;quot;myCache&amp;quot;);
        }};
        //设置多个缓存
        builder.initialCacheNames(cacheNames);
        return builder.build();
    }

    /**
     * 定义Redis连接工厂
     * @return
     */
    @Bean
    public JedisConnectionFactory redisConnectionFactory(){
        JedisConnectionFactory factory = new JedisConnectionFactory();
        factory.afterPropertiesSet();
        return factory;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;四、混合使用多种缓存CompositeCacheManager&lt;/p&gt;

&lt;p&gt;我们并不是只能有且仅有一个缓存管理器。如果你很难确定该使用哪个缓存管理器，或者有合法的技术理由使用超过一个缓存管理器的话，那么可以尝试使用 Spring 的 CompositeCacheManager.CompositeCacheManager 要通过一个或更多的缓存管理器来进行配置，它会迭代这些缓存管理器，以查找之前所缓存的值&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第十二章：Spring与NoSQL</title>
      <link>https://keep-zero.github.io/2019/spring_action12/</link>
      <pubDate>Sun, 01 Sep 2019 11:52:39 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action12/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;随着&lt;strong&gt;非关系型数据库（NoSQL数据库）&lt;/strong&gt;概念的流行，Spring也开始提供非关系型数据库的支持，Spring主要提供以下几种非关系型数据库的支持：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MongoDB&lt;/strong&gt; &amp;mdash;&amp;ndash;文档数据库，不是通用的数据库，它们所擅长解决的是一个很小的问题集&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Neo4j&lt;/strong&gt; &amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;图数据库。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Redis&lt;/strong&gt; &amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;键值对数据库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现如今用的比较多的NoSQL数据库是Redis数据库，我们以Spring整合Redis数据库为例了解Spring对NoSQL的支持&lt;/p&gt;

&lt;h2 id=&#34;一-spring-data-redis体系结构分析&#34;&gt;一、Spring Data Redis体系结构分析&lt;/h2&gt;

&lt;p&gt;Spring-data-redis提供了在srping应用中通过简单的配置访问redis服务，对reids底层开发包(Jedis, JRedis, and RJC)进行了高度封装，RedisTemplate提供了redis各种操作、异常处理及序列化，支持发布订阅，并对spring 3.1 cache进行了实现。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;连接到 Redis&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Redis 连接工厂会生成到 Redis 数据库服务器的连接。 Spring Data Redis 为四种 Redis 客户端实现提供了连接工厂：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;JedisConnectionFactory&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;mdash;-最为常用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;SrpConnectionFactory&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;LettuceConnectionFactory&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;JredisConnectionFactory&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;操作Redis&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RedisTemplate对应不同需求封装了如下操作：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;opsForValue&lt;/strong&gt;()&amp;mdash;&amp;mdash;普通键值对操作
&lt;strong&gt;opsForList&lt;/strong&gt;()&amp;mdash;&amp;mdash;&amp;mdash;ArrayList键值对操作
&lt;strong&gt;opsForSet&lt;/strong&gt;()&amp;mdash;&amp;mdash;&amp;mdash;HashSet键值对操作
&lt;strong&gt;opsForHash&lt;/strong&gt;()&amp;mdash;&amp;mdash;HashMap键值对操作&lt;/p&gt;

&lt;h2 id=&#34;二-spring-整合使用spring-data-redis&#34;&gt;二、Spring 整合使用Spring Data Redis&lt;/h2&gt;

&lt;p&gt;①引入依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--引入Spring Data Redis--&amp;gt;
&amp;lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-redis --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.data&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-data-redis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.5.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!--引入jedis支持--&amp;gt;
&amp;lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.9.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②编写redis配置文件：redis.properties&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#redis地址
redis.host=127.0.0.1
#redis端口
redis.port=6379
#redis密码，一般不需要
redis.password=&amp;quot;&amp;quot;
#最大空闲时间
redis.maxIdle=400
#最大连接数
redis.maxTotal=6000
#最大等待时间
redis.maxWaitMillis=1000
#连接耗尽时是否阻塞，false报异常，true阻塞超时 默认：true
redis.blockWhenExhausted=true
#在获得链接的时候检查有效性，默认false
redis.testOnBorrow=true
#超时时间，默认：2000
redis.timeout=100000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③编写Spring配置文件并配置Redis：application.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans.xsd 
       http://www.springframework.org/schema/context 
       http://www.springframework.org/schema/context/spring-context.xsd 
       http://www.springframework.org/schema/tx 
       http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop 
       http://www.springframework.org/schema/aop/spring-aop.xsd&amp;quot;&amp;gt;

    &amp;lt;!--开启注解扫描--&amp;gt;
    &amp;lt;context:annotation-config/&amp;gt;
    &amp;lt;!--指定组件扫描范围--&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.my.spring&amp;quot;/&amp;gt;

    &amp;lt;!--引入redis资源文件--&amp;gt;
    &amp;lt;context:property-placeholder location=&amp;quot;classpath*:redis.properties&amp;quot;/&amp;gt;

    &amp;lt;!-- redis数据源 --&amp;gt;
    &amp;lt;bean id=&amp;quot;poolConfig&amp;quot; class=&amp;quot;redis.clients.jedis.JedisPoolConfig&amp;quot;&amp;gt;
        &amp;lt;!-- 最大空闲数 --&amp;gt;
        &amp;lt;property name=&amp;quot;maxIdle&amp;quot; value=&amp;quot;${redis.maxIdle}&amp;quot; /&amp;gt;
        &amp;lt;!-- 最大空连接数 --&amp;gt;
        &amp;lt;property name=&amp;quot;maxTotal&amp;quot; value=&amp;quot;${redis.maxTotal}&amp;quot; /&amp;gt;
        &amp;lt;!-- 最大等待时间 --&amp;gt;
        &amp;lt;property name=&amp;quot;maxWaitMillis&amp;quot; value=&amp;quot;${redis.maxWaitMillis}&amp;quot; /&amp;gt;
        &amp;lt;!-- 连接超时时是否阻塞，false时报异常,ture阻塞直到超时, 默认true --&amp;gt;
        &amp;lt;property name=&amp;quot;blockWhenExhausted&amp;quot; value=&amp;quot;${redis.blockWhenExhausted}&amp;quot; /&amp;gt;
        &amp;lt;!-- 返回连接时，检测连接是否成功 --&amp;gt;
        &amp;lt;property name=&amp;quot;testOnBorrow&amp;quot; value=&amp;quot;${redis.testOnBorrow}&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- Spring-redis连接池管理工厂 --&amp;gt;
    &amp;lt;bean id=&amp;quot;jedisConnectionFactory&amp;quot; class=&amp;quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&amp;quot;&amp;gt;
        &amp;lt;!-- IP地址 --&amp;gt;
        &amp;lt;property name=&amp;quot;hostName&amp;quot; value=&amp;quot;${redis.host}&amp;quot; /&amp;gt;
        &amp;lt;!-- 端口号 --&amp;gt;
       &amp;lt;property name=&amp;quot;port&amp;quot; value=&amp;quot;${redis.port}&amp;quot; /&amp;gt;
        &amp;lt;!-- 超时时间 默认2000--&amp;gt;
        &amp;lt;property name=&amp;quot;timeout&amp;quot; value=&amp;quot;${redis.timeout}&amp;quot; /&amp;gt;
        &amp;lt;!-- 连接池配置引用 --&amp;gt;
        &amp;lt;property name=&amp;quot;poolConfig&amp;quot; ref=&amp;quot;poolConfig&amp;quot; /&amp;gt;
        &amp;lt;!-- usePool：是否使用连接池 --&amp;gt;
        &amp;lt;property name=&amp;quot;usePool&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 注册RedisTemplate --&amp;gt;
    &amp;lt;bean id=&amp;quot;redisTemplate&amp;quot; class=&amp;quot;org.springframework.data.redis.core.RedisTemplate&amp;quot;&amp;gt;
        &amp;lt;!--注入连接池管理工具--&amp;gt;
        &amp;lt;property name=&amp;quot;connectionFactory&amp;quot; ref=&amp;quot;jedisConnectionFactory&amp;quot; /&amp;gt;
        &amp;lt;!--设置Redis的key序列化方式--&amp;gt;
        &amp;lt;property name=&amp;quot;keySerializer&amp;quot;&amp;gt;
            &amp;lt;bean class=&amp;quot;org.springframework.data.redis.serializer.StringRedisSerializer&amp;quot; /&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!--设置Redis的value序列化方式--&amp;gt;
        &amp;lt;property name=&amp;quot;valueSerializer&amp;quot;&amp;gt;
            &amp;lt;bean class=&amp;quot;org.springframework.data.redis.serializer.StringRedisSerializer&amp;quot; /&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!--设置Redis存入haseMap时的key序列化方式--&amp;gt;
        &amp;lt;property name=&amp;quot;hashKeySerializer&amp;quot;&amp;gt;
            &amp;lt;bean class=&amp;quot;org.springframework.data.redis.serializer.StringRedisSerializer&amp;quot; /&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!--设置Redis存入haseMap时的value序列化方式--&amp;gt;
        &amp;lt;property name=&amp;quot;hashValueSerializer&amp;quot;&amp;gt;
            &amp;lt;bean class=&amp;quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&amp;quot; /&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;!--开启事务  --&amp;gt;
        &amp;lt;property name=&amp;quot;enableTransactionSupport&amp;quot; value=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--自定义redis工具类  --&amp;gt;
    &amp;lt;bean id=&amp;quot;redisHelper&amp;quot; class=&amp;quot;com.my.spring.util.RedisHelper&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;redisTemplate&amp;quot; ref=&amp;quot;redisTemplate&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;④编写Redis工具类:RedisManager,注入RedisTemplate&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data
public class RedisHelper {

    //注入RedisTemplate
    private RedisTemplate&amp;lt;String,Object&amp;gt; redisTemplate;

    /**
     * 设置过期时间
     * @param key
     * @param time
     * @return
     */
    public boolean expire(String key, long time) {
        return this.redisTemplate.expire(key,time, TimeUnit.SECONDS);
    }

     /**
     * 是否存在key
     * @param key
     * @return
     */
    public Object hasKey(String key){
        return this.redisTemplate.hasKey(key);
    }

    /**
     * 获取过期时间
     * @param key
     * @return
     */
    public long getExpire(String key){
        return this.redisTemplate.getExpire(key);
    }

    /**
     * 根据key获取值
     * @param key
     * @return
     */
    public Object get(String key){
        Object o = redisTemplate.opsForValue().get(key);
        return o;
    }

    /**
     * 存储key-value
     * @param key
     * @param value
     * @return
     */
    public boolean set(String key,Object value){
        redisTemplate.opsForValue().set(key,value);
        return true;
    }

    /**
     * 存入key-value并设置过期时间，以秒为单位
     * @param key
     * @param value
     * @param time
     * @return
     */
    public boolean set(String key,Object value,long time){
        redisTemplate.opsForValue().set(key,value,time,TimeUnit.SECONDS);
        return true;
    }

    /**
     * 将值以set形式存入redis中
     * @param key
     * @param values
     * @return
     */
    public long sSet(String key,Object ...values){
        return this.redisTemplate.opsForSet().add(key,values);
    }

    /**
     * 获取键为key的set
     * @param key
     * @return
     */
    public Set&amp;lt;String&amp;gt; sGet(String key){
        return this.redisTemplate.opsForSet().members(key);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑤编写测试类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&amp;quot;classpath:application.xml&amp;quot;})
public class AppTest {

    @Autowired
    private RedisHelper redisHelper;

    @Test
    public void testSet(){
       this.redisHelper.set(&amp;quot;testKey&amp;quot;,&amp;quot;testValue&amp;quot;)
    }

   @Test
    public void testGet(){
        System.out.println(this.redisHelper.get(&amp;quot;testKey&amp;quot;));
    }

    @Test
    public void testsSet(){
       this.redisHelper.sSet(&amp;quot;testKey2&amp;quot;,&amp;quot;testValue1&amp;quot;,&amp;quot;testValue2&amp;quot;,&amp;quot;testValue3&amp;quot;)
    }

    @Test
    public void testsGet(){
        Set&amp;lt;String&amp;gt; set = this.redisHelper.sGet(&amp;quot;testKey2&amp;quot;);
        System.out.println(set.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行测试，测试结果：&lt;/p&gt;

&lt;p&gt;运行testSet():&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_12_01.jpg&#34; alt=&#34;&#34; /&gt;
运行testGet():&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;testValue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行testsSet():&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_12_02.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;运行testsGet():&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;[testValue1, testValue3, testValue2]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第十一章：利用对象-关系映射持久化数据（Spring整合Spring Data ）</title>
      <link>https://keep-zero.github.io/2019/spring_action11_03/</link>
      <pubDate>Sun, 01 Sep 2019 11:52:25 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action11_03/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;ⅰ-spring-data-jpa简介&#34;&gt;&lt;strong&gt;Ⅰ、Spring Data JPA简介&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Spring-Data&lt;/strong&gt;:Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。&lt;/p&gt;

&lt;p&gt;Spring-data系列产品：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spring Data Common&lt;/strong&gt;:提供共享的基础框架，适合各个子项目使用，支持跨数据库持久化
&lt;strong&gt;Spring Data JDBC&lt;/strong&gt;:提供对关系数据库的访问，而无需处理JPA的复杂性
&lt;strong&gt;Spring Data JDBC Extensions&lt;/strong&gt;:支持 Oracle RAD、高级队列和高级数据类型
&lt;strong&gt;Spring Data JPA&lt;/strong&gt;:简化创建 JPA 数据访问层和跨存储的持久层功能
&lt;strong&gt;Spring Data Mongodb&lt;/strong&gt;:提供对文档数据库的支持
&lt;strong&gt;Spring Data Redis&lt;/strong&gt;:提供对键值对数据库的支持&lt;/p&gt;

&lt;p&gt;其中，Spring-data-jpa是 Spring 基于 ORM 框架、JPA 规范的基础上封装的&lt;strong&gt;一套 JPA 应用框架&lt;/strong&gt;，&lt;strong&gt;底层使用了 Hibernate 的 JPA 技术实现&lt;/strong&gt;，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单来说，其目的在于简化Spring未简化的持久层业务工作，开发者仅需要完成的是声明持久层接口，其余则由Spring Data JPA来完成&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;ⅱ-spring-data-jpa架构体系分析&#34;&gt;&lt;strong&gt;Ⅱ、Spring Data JPA架构体系分析&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;如上所述，我们知道Spring Data JPA依赖于接口即可实现持久层操作，那么了解它提供的核心接口类，即可开始我们的使用：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Repository&lt;/strong&gt;：最顶层的接口，是一个空的接口，目的是为了统一所有Repository的类型，且能让组件扫描的时候自动识别
&lt;strong&gt;Specification&lt;/strong&gt;：Spring Data JPA提供的一个查询规范，要做复杂的查询，只需围绕这个规范来设置查询条件
&lt;strong&gt;CrudRepository接口&lt;/strong&gt;：提供了CRUD的基本功能
&lt;strong&gt;PagingAndSortingRepository分页排序接口&lt;/strong&gt;：封装了查询分页和排序的功能
&lt;strong&gt;JpaRepository接口&lt;/strong&gt;：&lt;strong&gt;PagingAndSortingRepository&lt;/strong&gt;和QueryByExampleExecutor的子接口，除了提供CRUD的功能之外，还额外提供了分页和排序、过滤等功能
** JpaSpecificationExecutor接口**：提供了对JPA Criteria查询（动态查询）的支持&lt;/p&gt;

&lt;p&gt;以下分析部分源码：
①Repository&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;T：要操作的实体类类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ID:实体类的主键类型class&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Indexed
public interface Repository&amp;lt;T, ID&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②CrudRepository&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@NoRepositoryBean
public interface CrudRepository&amp;lt;T, ID&amp;gt; extends Repository&amp;lt;T, ID&amp;gt; {

    //保存一个实体记录，返回保存后的实体
    &amp;lt;S extends T&amp;gt; S save(S var1);

    //保存传入的实体列表，返回保存后的实体列表
    &amp;lt;S extends T&amp;gt; Iterable&amp;lt;S&amp;gt; saveAll(Iterable&amp;lt;S&amp;gt; var1);

    //根据主键查询实体，返回封装实体信息的对象
    Optional&amp;lt;T&amp;gt; findById(ID var1);

    //根据主键查询数据库是否已存在该记录，返回boolean值
    boolean existsById(ID var1);

    //获取数据表所有记录，返回实体列表
    Iterable&amp;lt;T&amp;gt; findAll();

    //根据主键列表获取对应实体记录，返回实体列表
    Iterable&amp;lt;T&amp;gt; findAllById(Iterable&amp;lt;ID&amp;gt; var1);

    //统计数据表记录总数
    long count();

    //根据主键删除记录
    void deleteById(ID var1);

    //根据对象删除记录
    void delete(T var1);

    //根据传入的对象列表删除记录
    void deleteAll(Iterable&amp;lt;? extends T&amp;gt; var1);

    //清空数据表
    void deleteAll();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③PagingAndSortingRepository&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@NoRepositoryBean
public interface PagingAndSortingRepository&amp;lt;T, ID&amp;gt; extends CrudRepository&amp;lt;T, ID&amp;gt; {
    //获取数据表所有记录并根据传入的Sort对象进行排序，返回实体列表
    Iterable&amp;lt;T&amp;gt; findAll(Sort var1);

    //获取数据表所有记录并根据传入的分页对象进行分页排序，返回实体列表
    Page&amp;lt;T&amp;gt; findAll(Pageable var1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;④JpaSpecificationExecutor&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface JpaSpecificationExecutor&amp;lt;T&amp;gt; {
    //根据传入的条件对象查询某个实体，返回实体
    Optional&amp;lt;T&amp;gt; findOne(@Nullable Specification&amp;lt;T&amp;gt; var1);

    //根据传入的条件对象查询符合条件的实体，返回实体列表
    List&amp;lt;T&amp;gt; findAll(@Nullable Specification&amp;lt;T&amp;gt; var1);

    //根据传入的条件对象和分页对象查询符合条件的实体，返回实体分页列表
    Page&amp;lt;T&amp;gt; findAll(@Nullable Specification&amp;lt;T&amp;gt; var1, Pageable var2);

    //根据传入的条件对象查询实体并根据Sort对象排序，返回实体列表
    List&amp;lt;T&amp;gt; findAll(@Nullable Specification&amp;lt;T&amp;gt; var1, Sort var2);

    //根据传入的条件对象查询符合条件的实体个数，返回个数
    long count(@Nullable Specification&amp;lt;T&amp;gt; var1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑤JpaRepository&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@NoRepositoryBean
public interface JpaRepository&amp;lt;T, ID&amp;gt; extends PagingAndSortingRepository&amp;lt;T, ID&amp;gt;, QueryByExampleExecutor&amp;lt;T&amp;gt; {
    //获取数据表所有记录，返回实体列表
    List&amp;lt;T&amp;gt; findAll();
    //获取数据表所有记录并根据Sort对象进行排序，返回实体列表
    List&amp;lt;T&amp;gt; findAll(Sort var1);

    //根据主键列表获取对应实体记录，返回实体列表
    List&amp;lt;T&amp;gt; findAllById(Iterable&amp;lt;ID&amp;gt; var1);

    //保存传入的实体列表，返回保存后的实体列表
    &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; saveAll(Iterable&amp;lt;S&amp;gt; var1);

    //清除session缓存
    void flush();

    //保存并清除session缓存
    &amp;lt;S extends T&amp;gt; S saveAndFlush(S var1);

    //根据传入的实体对象批量删除数据表记录
    void deleteInBatch(Iterable&amp;lt;T&amp;gt; var1);

    //清空数据库表
    void deleteAllInBatch();

    //根据主键获取实体，返回实体
    T getOne(ID var1);

    //根据传入的Example对象获取符合条件的实体，返回实体列表
    &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; var1);

    //根据传入的Example对象获取符合条件的实体并根据Sort对象进行排序，返回实体列表
    &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; var1, Sort var2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ⅲ-spring整合使用sring-data-jpa&#34;&gt;&lt;strong&gt;Ⅲ、Spring整合使用Sring Data JPA&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;① 引入依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--logback日志实现引入--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;logback-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.1.7&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;logback-access&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.1.7&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.1.7&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--slf4j日志门面引入--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.7.7&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入alibaba的数据库连接池--&amp;gt;
    &amp;lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.1.10&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入Spring支持--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入Spring事务--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-tx&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入Spring对ORM框架的支持依赖--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-orm&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入jpa支持--&amp;gt;
    &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-jpa --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.data&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-data-jpa&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.4.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入Hibernate对象管理器--&amp;gt;
    &amp;lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-entitymanager --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;hibernate-entitymanager&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;5.4.1.Final&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入数据库驱动--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②配置jpa&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot; xmlns:tx=&amp;quot;http://www.springframework.org/schema/tx&amp;quot;
       xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot; xmlns:jpa=&amp;quot;http://www.springframework.org/schema/data/jpa&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&amp;quot;&amp;gt;

    &amp;lt;!--开启注解--&amp;gt;
    &amp;lt;context:annotation-config/&amp;gt;

    &amp;lt;!--配置组件扫描范围--&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.my.spring&amp;quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;

    &amp;lt;!-- 导入资源文件 --&amp;gt;
    &amp;lt;context:property-placeholder location=&amp;quot;classpath:datasource.properties&amp;quot;/&amp;gt;

    &amp;lt;!--配置数据库连接池--&amp;gt;
    &amp;lt;bean class=&amp;quot;com.alibaba.druid.pool.DruidDataSource&amp;quot; id=&amp;quot;dataSource&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;maxActive&amp;quot; value=&amp;quot;${druid.maxActive}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;maxWait&amp;quot; value=&amp;quot;${druid.maxWait}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;timeBetweenEvictionRunsMillis&amp;quot; value=&amp;quot;${druid.timeBetweenEvictionRunsMillis}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--配置JPA的持久化实现厂商类--&amp;gt;
    &amp;lt;bean id=&amp;quot;jpaVendorAdapter&amp;quot; class=&amp;quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&amp;quot;&amp;gt;
        &amp;lt;!-- 自动检查注解的实体和数据表，如果数据库不存在的标，会根据实体自动生成 --&amp;gt;
        &amp;lt;property name=&amp;quot;generateDdl&amp;quot; value=&amp;quot;true&amp;quot; /&amp;gt;
        &amp;lt;property name=&amp;quot;database&amp;quot; value=&amp;quot;HSQL&amp;quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--配置Jpa Entity Manager--&amp;gt;
    &amp;lt;bean id=&amp;quot;entityManagerFactory&amp;quot; class=&amp;quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&amp;quot; lazy-init=&amp;quot;false&amp;quot;&amp;gt;
        &amp;lt;!--注入数据库--&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot; /&amp;gt;

        &amp;lt;!-- 指定Jpa持久化实现厂商类,这里以Hibernate为例 --&amp;gt;
        &amp;lt;property name=&amp;quot;jpaVendorAdapter&amp;quot; ref=&amp;quot;jpaVendorAdapter&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;

        &amp;lt;!-- 指定Entity实体类包路径，使用注解方式进行映射 --&amp;gt;
        &amp;lt;property name=&amp;quot;packagesToScan&amp;quot; value=&amp;quot;com.my.spring.bean&amp;quot; /&amp;gt;

        &amp;lt;!-- 指定JPA属性；如Hibernate中指定是否显示SQL的是否显示、方言等 --&amp;gt;
        &amp;lt;property name=&amp;quot;jpaProperties&amp;quot;&amp;gt;
            &amp;lt;props&amp;gt;
                &amp;lt;!-- 命名规则 My_NAME-&amp;gt;MyName --&amp;gt;
                &amp;lt;prop key=&amp;quot;hibernate.ejb.naming_strategy&amp;quot;&amp;gt;org.hibernate.cfg.DefaultComponentSafeNamingStrategy&amp;lt;/prop&amp;gt;
                &amp;lt;!-- 打印sql语句 --&amp;gt;
                &amp;lt;prop key=&amp;quot;hibernate.show_sql&amp;quot;&amp;gt;true&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&amp;quot;hibernate.dialect&amp;quot;&amp;gt;org.hibernate.dialect.MySQL5Dialect&amp;lt;/prop&amp;gt;
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--配置jpa的方言对象--&amp;gt;
    &amp;lt;bean id=&amp;quot;jpaDialect&amp;quot; class=&amp;quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&amp;quot; /&amp;gt;

    &amp;lt;!-- 配置Spring声明式事务 --&amp;gt;
    &amp;lt;bean id=&amp;quot;transactionManager&amp;quot; class=&amp;quot;org.springframework.orm.jpa.JpaTransactionManager&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;entityManagerFactory&amp;quot; ref=&amp;quot;entityManagerFactory&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--开启注解事务--&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&amp;quot;transactionManager&amp;quot;/&amp;gt;

    &amp;lt;!-- 重要配置：启用扫描并自动创建代理的功能 --&amp;gt;
    &amp;lt;jpa:repositories base-package=&amp;quot;com.my.spring&amp;quot; transaction-manager-ref=&amp;quot;transactionManager&amp;quot; entity-manager-factory-ref=&amp;quot;entityManagerFactory&amp;quot; /&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③编写实体类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity//指定当前实体类需要被扫描
@Table(name = &amp;quot;basebean&amp;quot;)//指定当前实体类映射到数据库表名
public class BaseBean {

    @Id//当前字段为主键字段
    @GeneratedValue(strategy = GenerationType.IDENTITY)//指定id自增
    private Integer id;

    private String name;

    private Integer age;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;④编写Repository接口,继承CrudRepository接口，获得默认接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BaseRepository extends CrudRepository&amp;lt;BaseBean,Integer&amp;gt;{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑤编写Service和Service实现类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BaseService {
    /**
     *  保存记录
     * @param baseBean
     * @return
     */
    void save(BaseBean baseBean);

    /**
     * 获取所有记录
     * @return
     */
    List&amp;lt;BaseBean&amp;gt; findAll();

    /**
     * 获取指定id记录
     * @param id
     * @return
     */
    BaseBean findOne(Integer id);
}

@Component
public class BaseServiceImpl implements BaseService {

    @Autowired
    private BaseRepository baseRepository;

    @Override
    @Transactional(rollbackFor = RuntimeException.class)
    public void save(BaseBean baseBean) {
        this.baseRepository.save(baseBean);
    }

    @Override
    public List&amp;lt;BaseBean&amp;gt; findAll() {
        Iterable&amp;lt;BaseBean&amp;gt; iterable = this.baseRepository.findAll();
        if(null!=iterable){
            return (List&amp;lt;BaseBean&amp;gt;) iterable;
        }

        return null;
    }

    @Override
    public BaseBean findOne(Integer id) {
        Optional&amp;lt;BaseBean&amp;gt; optional = this.baseRepository.findById(id);
        if(null!=optional){
            return optional.get();
        }
        return null;

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑥编写测试类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&amp;quot;classpath:application.xml&amp;quot;})//以application.xml为配置环境文件
public class JPATest {

    @Autowired
    private BaseService baseService;

    @Autowired
    private ApplicationContext applicationContext;

    @Test
    public void testJPA() {
        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames){
            System.out.println(beanDefinitionName);
        }
    }

    @Test
    public void testSave(){
        BaseBean baseBean = new BaseBean();
        baseBean.setName(&amp;quot;jpa bean&amp;quot;);
        baseBean.setAge(50);
        this.baseService.save(baseBean);
    }

    @Test
    public void testFindAll(){
        List&amp;lt;BaseBean&amp;gt; list = this.baseService.findAll();
        if(null==list||list.isEmpty()){
            System.err.println(&amp;quot;空表&amp;quot;);
        }else{
            for (BaseBean baseBean : list){
                System.err.println(baseBean.toString());
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行测试，测试结果：&lt;/p&gt;

&lt;p&gt;testJPA()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.annotation.internalPersistenceAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
baseServiceImpl
org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0
dataSource
jpaVendorAdapter
entityManagerFactory
jpaDialect
transactionManager
org.springframework.transaction.config.internalTransactionalEventListenerFactory
org.springframework.aop.config.internalAutoProxyCreator
org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0
org.springframework.transaction.interceptor.TransactionInterceptor#0
org.springframework.transaction.config.internalTransactionAdvisor
org.springframework.data.jpa.repository.config.JpaRepositoryConfigExtension#0
emBeanDefinitionRegistrarPostProcessor
jpaMappingContext
jpaContext
org.springframework.data.jpa.util.JpaMetamodelCacheCleanup
baseRepository
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;testSave()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;insert into basebean (age, name) values (?, ?)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;testFindAll()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;BaseBean(id=1, name=jpa bean, age=50)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第十一章：利用对象-关系映射持久化数据（Spring整合Hibernate）</title>
      <link>https://keep-zero.github.io/2019/spring_action11_02/</link>
      <pubDate>Sun, 01 Sep 2019 11:52:21 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action11_02/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;ⅰ-hibernate架构体系分析&#34;&gt;&lt;strong&gt;Ⅰ、Hibernate架构体系分析&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;先来了解一下Hibernate的框架体系，下图为官方Hibernate简要体系结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_11_02_01.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Hibernate通过持久化对象Persistent Objects（PO）对数据库进行操作，底层数据库操作 对于应用程序来说是透明的，应用程序无需关心JDBC操作，底层数据库连接、数据库访问实现、事务控制，而是直接以面向对象方式进行持久层的操作。&lt;/p&gt;

&lt;p&gt;Hibernate详细的框架体系如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://upload-images.jianshu.io/upload_images/1279274-6213a927ff0948ad?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;SessionFactory:&lt;/strong&gt;&lt;strong&gt;是依赖于ConnectionProvider的会话和客户端工厂。 它拥有数据的二级缓存(可选)。 org.hibernate.SessionFactory接口提供了工厂方法来获取Session的对象。（实现了&lt;/strong&gt;&lt;strong&gt;EntityManagerFactory&lt;/strong&gt;&lt;strong&gt;接口）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Session:&lt;/strong&gt;&lt;strong&gt;应用程序与持久层之间交互操作的一个单线程对象。所有的持久化对象必须在Session管理下才能进行持久化操作。它底层封装了JDBC连接，是Transaction工厂。(实现了&lt;/strong&gt;&lt;strong&gt;EntityManager&lt;/strong&gt;&lt;strong&gt;接口)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久化对象（PO）：系统创建的POJO实例，一旦与特定的Session关联，并对应数据表的指定记录，该对象就处于持久化状态。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事务（Transaction）：代表一次原子操作，Hibernate事务是对底层具体的JDBC，JTA以及CORBA事务的抽象。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接提供者（ConnectionProvider）：生成JDBC连接的工厂，通过抽象将应用程序与底层的DataSource或DriverManager隔离开。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事务工厂(TransactionFactory)：它是一个事务工厂，是一个可选项。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如下是一次数据库请求操作的执行过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_11_02_02.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;①应用程序调用&lt;strong&gt;Configuration&lt;/strong&gt;读取配置文件（映射文件和hibernate.propertise），并据此生成&lt;strong&gt;SessionFactory&lt;/strong&gt;工厂对象。&lt;/p&gt;

&lt;p&gt;②&lt;strong&gt;SessionFactory&lt;/strong&gt;生产&lt;strong&gt;Session&lt;/strong&gt;操作对象，通过Session对象对数据库执行CRUD操作，同时生成&lt;strong&gt;Transaction&lt;/strong&gt;对象&lt;/p&gt;

&lt;p&gt;③如果&lt;strong&gt;Session&lt;/strong&gt;执行操作正常，&lt;strong&gt;Transaction&lt;/strong&gt;提交事务将结果真正生成至数据库，如果操作异常，则执行事务回滚&lt;/p&gt;

&lt;h2 id=&#34;ⅱ-spring整合使用hibernate&#34;&gt;&lt;strong&gt;Ⅱ、Spring整合使用Hibernate&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;①引入依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--logback日志实现引入--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;logback-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.1.7&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;logback-access&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.1.7&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.1.7&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--slf4j日志门面引入--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.7.7&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入alibaba的数据库连接池--&amp;gt;
    &amp;lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.1.10&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入Spring支持--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入Spring事务--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-tx&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入Spring对ORM框架的支持依赖--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-orm&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入Hibernate支持--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;hibernate-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${hibernate.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;hibernate-entitymanager&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${hibernate.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;hibernate-ehcache&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${hibernate.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;net.sf.ehcache&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;ehcache&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.9.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入数据库驱动--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②编写实体类：BaseBean&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data//lombok注解，默认添加setter,getter方法
@ToString//lombok注解，默认改写toString()方法
public class BaseBean {

    private Integer id;

    private String name;

    private Integer age;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③编写实体类映射文件：BaseBean.hbm.xml,将BaseBean实体类与数据库表basebean关联映射&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE hibernate-mapping PUBLIC &amp;quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&amp;quot;
        &amp;quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&amp;quot;&amp;gt;
&amp;lt;!--&amp;lt;!DOCTYPE hibernate-mapping PUBLIC &amp;quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&amp;quot; &amp;quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&amp;quot;&amp;gt;--&amp;gt;

        &amp;lt;!-- Generated 2016-3-15 16:30:05 by Hibernate Tools 3.4.0.CR1 --&amp;gt;
&amp;lt;hibernate-mapping&amp;gt;
    &amp;lt;class name=&amp;quot;com.my.spring.bean.BaseBean&amp;quot; table=&amp;quot;basebean&amp;quot;&amp;gt;
        &amp;lt;id name=&amp;quot;id&amp;quot; type=&amp;quot;java.lang.Integer&amp;quot; column=&amp;quot;id&amp;quot;&amp;gt;
            &amp;lt;generator class=&amp;quot;native&amp;quot; /&amp;gt;
        &amp;lt;/id&amp;gt;
        &amp;lt;property name=&amp;quot;name&amp;quot; type=&amp;quot;java.lang.String&amp;quot; column=&amp;quot;name&amp;quot;/&amp;gt;
        &amp;lt;property name=&amp;quot;age&amp;quot; type=&amp;quot;java.lang.Integer&amp;quot; column=&amp;quot;age&amp;quot;/&amp;gt;
    &amp;lt;/class&amp;gt;
&amp;lt;/hibernate-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;映射文件和实体类位置如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_11_02_03.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;④编写数据库资源文件:dataSource.properties&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#指定数据库驱动
jdbc.driver = com.mysql.jdbc.Driver

#指定数据库url
jdbc.url = jdbc:mysql://localhost:3306/spring

#指定数据库用户
jdbc.username = spring

#指定数据库用户密码
jdbc.password = spring

#指定使用的数据库连接池
druid.dataSource=com.alibaba.druid.pool.DruidDataSource

#指定最大活跃连接数
druid.maxActive=10

#指定等待连接超时时间，单位毫秒
druid.maxWait=10000

#指定间隔扫描连接时间，检测需要关闭的空闲连接，单位是毫秒
druid.timeBetweenEvictionRunsMillis=60000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑤编写Spring配置文件:application.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot; xmlns:tx=&amp;quot;http://www.springframework.org/schema/tx&amp;quot;
       xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&amp;quot;&amp;gt;
    &amp;lt;!--开启 spring注解扫描--&amp;gt;
    &amp;lt;context:annotation-config/&amp;gt;
     &amp;lt;!--配置组件扫描范围--&amp;gt;
    &amp;lt;context:component-scan base-package=&amp;quot;com.my.spring&amp;quot;&amp;gt;&amp;lt;/context:component-scan&amp;gt;

    &amp;lt;!-- 导入资源文件 --&amp;gt;
    &amp;lt;context:property-placeholder location=&amp;quot;classpath:datasource.properties&amp;quot;/&amp;gt;

    &amp;lt;!--配置数据库连接池--&amp;gt;
    &amp;lt;bean class=&amp;quot;com.alibaba.druid.pool.DruidDataSource&amp;quot; id=&amp;quot;dataSource&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;maxActive&amp;quot; value=&amp;quot;${druid.maxActive}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;maxWait&amp;quot; value=&amp;quot;${druid.maxWait}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;timeBetweenEvictionRunsMillis&amp;quot; value=&amp;quot;${druid.timeBetweenEvictionRunsMillis}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--配置Hibernate下的SessionFactory--&amp;gt;
    &amp;lt;bean id=&amp;quot;sessionFactory&amp;quot; class=&amp;quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&amp;quot; lazy-init=&amp;quot;false&amp;quot;&amp;gt;
        &amp;lt;!--注入数据库--&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot; /&amp;gt;
        &amp;lt;!-- //加载实体类的映射文件位置及名称 --&amp;gt;
        &amp;lt;property name=&amp;quot;mappingLocations&amp;quot; value=&amp;quot;classpath*:/com/my/spring/bean/*.hbm.xml&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;

        &amp;lt;!--配置hibernate的主配置属性--&amp;gt;
        &amp;lt;property name=&amp;quot;hibernateProperties&amp;quot;&amp;gt;
            &amp;lt;props&amp;gt;
                 &amp;lt;!--是否显示执行sql--&amp;gt;
                &amp;lt;prop key=&amp;quot;hibernate.show_sql&amp;quot;&amp;gt;true&amp;lt;/prop&amp;gt;
                 &amp;lt;!--数据库表策略--&amp;gt;
                &amp;lt;prop key=&amp;quot;hibernate.hbm2ddl.auto&amp;quot;&amp;gt;update&amp;lt;/prop&amp;gt;
                 &amp;lt;!--数据库方言--&amp;gt;
                &amp;lt;prop key=&amp;quot;hibernate.dialect&amp;quot;&amp;gt;org.hibernate.dialect.MySQL5Dialect&amp;lt;/prop&amp;gt;
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 配置Spring声明式事务 --&amp;gt;
    &amp;lt;bean id=&amp;quot;transactionManager&amp;quot; class=&amp;quot;org.springframework.orm.hibernate5.HibernateTransactionManager&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;sessionFactory&amp;quot; ref=&amp;quot;sessionFactory&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--开启注解事务--&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&amp;quot;transactionManager&amp;quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑥编写数据库操作接口和实现类：BaseBeanRepository.java&amp;amp;BaseBeanRepositoryImpl.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BaseRepository {

    /**
     *  保存记录
     * @param baseBean
     * @return
     */
    void save(BaseBean baseBean);

    /**
     * 获取所有记录
     * @return
     */
    List&amp;lt;BaseBean&amp;gt; findAll();

    /**
     * 获取指定id记录
     * @param id
     * @return
     */
    BaseBean findOne(Integer id);
}

@Repository
public class BaseRepositoryImpl implements BaseRepository {

    //注入sessionFactory，用于获取session
    @Autowired
    private SessionFactory sessionFactory;

    //获取session
    public Session getSession(){
        return sessionFactory.getCurrentSession();
    }

    @Override
    public void save(BaseBean baseBean) {
        this.getSession().saveOrUpdate(baseBean);
    }

    @Override
    public List&amp;lt;BaseBean&amp;gt; findAll() {
        String hql = &amp;quot;FROM BaseBean&amp;quot;;
        Query query = this.getSession().createQuery(hql);
        return query.list();
    }

    @Override
    public BaseBean findOne(Integer id) {
        String hql = &amp;quot;FROM BaseBean Where id=?&amp;quot;;
        Query query = this.getSession().createQuery(hql).setParameter(0,id);
        return (BaseBean) query.uniqueResult();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑦编写逻辑处理接口和实现类：BaseService.java&amp;amp;BaseServiceImpl.java&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BaseService {
    /**
     *  保存记录
     * @param baseBean
     * @return
     */
    void save(BaseBean baseBean);

    /**
     * 获取所有记录
     * @return
     */
    List&amp;lt;BaseBean&amp;gt; findAll();

    /**
     * 获取指定id记录
     * @param id
     * @return
     */
    BaseBean findOne(Integer id);
}

@Component
@Transactional(rollbackFor = {RuntimeException.class})
public class BaseServiceImpl implements BaseService {

    //注入baseRepository操作类
    @Autowired
    private BaseRepository baseRepository;

    @Override
    public void save(BaseBean baseBean) {
        this.baseRepository.save(baseBean);
    }

    @Override
    public List&amp;lt;BaseBean&amp;gt; findAll() {
        return this.baseRepository.findAll();
    }

    @Override
    public BaseBean findOne(Integer id) {
        return this.baseRepository.findOne(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑧编写测试类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&amp;quot;classpath:application.xml&amp;quot;})
public class AppTest 
{
    @Autowired
    private BaseService baseService;

    @Autowired
    private ApplicationContext applicationContext;

    @Test
    public void testHibernate() throws SQLException {
        String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames){
            System.out.println(beanDefinitionName);
        }
    }

    @Test
    public void testSave(){
        BaseBean baseBean = new BaseBean();
        baseBean.setName(&amp;quot;hibernate bean&amp;quot;);
        baseBean.setAge(50);
        this.baseService.save(baseBean);
    }

    @Test
    public void testFindAll(){
        List&amp;lt;BaseBean&amp;gt; list = this.baseService.findAll();
        if(null==list||list.isEmpty()){
            System.out.println(&amp;quot;空表&amp;quot;);
        }else{
            for (BaseBean baseBean : list){
                System.out.println(baseBean.toString());
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑨测试结果：&lt;/p&gt;

&lt;p&gt;执行testHibernate()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor
org.springframework.context.annotation.internalPersistenceAnnotationProcessor
org.springframework.context.event.internalEventListenerProcessor
org.springframework.context.event.internalEventListenerFactory
baseRepositoryImpl
baseServiceImpl
org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0
dataSource
sessionFactory
transactionManager
org.springframework.transaction.config.internalTransactionalEventListenerFactory
org.springframework.aop.config.internalAutoProxyCreator
org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0
org.springframework.transaction.interceptor.TransactionInterceptor#0
org.springframework.transaction.config.internalTransactionAdvisor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行 testSave()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;2019-03-18 11:34:31.537 DEBUG org.hibernate.SQL - insert into basebean (name, age) values (?, ?)
Hibernate: insert into basebean (name, age) values (?, ?)
2019-03-18 11:34:31.556 DEBUG org.hibernate.id.IdentifierGeneratorHelper - Natively generated identity: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行testFindAll()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;2019-03-18 11:37:22.901 DEBUG org.hibernate.SQL - select basebean0_.id as id1_0_, basebean0_.name as name2_0_, basebean0_.age as age3_0_ from basebean basebean0_
Hibernate: select basebean0_.id as id1_0_, basebean0_.name as name2_0_, basebean0_.age as age3_0_ from basebean basebean0_

BaseBean(id=1, name=hibernate bean, age=50)
BaseBean(id=2, name=hibernate bean, age=50)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第十一章：利用对象-关系映射持久化数据</title>
      <link>https://keep-zero.github.io/2019/spring_action11_01/</link>
      <pubDate>Sun, 01 Sep 2019 11:52:10 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action11_01/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;原文链接：&lt;a href=&#34;https://blog.csdn.net/Laiguanfu/article/details/88858301&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;《Spring实战》-第十一章：利用对象-关系映射持久化数据&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-什么是对象-关系映射-orm-为什么需要对象-关系映射&#34;&gt;一、什么是对象-关系映射（ORM）/为什么需要对象-关系映射&lt;/h2&gt;

&lt;p&gt;先来了解几个概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;瞬时状态：在程序运行的时候，有些数据保存在内存中，当程序退出后，这些数据就不复存在了，称这些数据的状态是瞬时的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久状态：数据以文件形式保存在辅存中，这样，程序退出后，数据依然存在，这种状态称之为持久的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久化 ：即在程序中的瞬时状态和持久状态之间转换的机制。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实际上，我们通常所说的持久化，一般指的持久化数据到数据库中。&lt;/p&gt;

&lt;p&gt;在数据持久化的世界里面，传统的dao已经很难满足开发的需求，或者显得过于臃肿耦合，程序代码中存在大量的问号字符串（SQL语句）。那么，使用对象-关系映射将对象属性映射到数据库表的列字段，从而实现操作对象以操作数据记录，简化代码就很有必要了，同时我们还需要学习用到几个特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;延迟加载（ Lazy loading ）：&lt;/strong&gt;随着我们的对象关系变得越来越复杂，有时候我们并不希望立即获取完整的对象间关系。举一个典型的例子，假设我们在查询一组 PurchaseOrder 对象，而每个对象中都包含一个 LineItem 对象集合。如果我们只关心 PurchaseOrder 的属性，那查询出 LineItem 的数据就毫无意义。而且这可能是开销很大的操作。延迟加载允许我们只在需要的时候获取数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预先抓取（ Eager fetching ）：&lt;/strong&gt;这与延迟加载是相对的。借助于预先抓取，我们可以使用一个查询获取完整的关联对象。如果我们需要 PurchaseOrder 及其关联的 LineItem 对象，预先抓取的功能可以在一个操作中将它们全部从数据库中取出来，节省了多次查询的成本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;级联（ Cascading ）：&lt;/strong&gt;有时，更改数据库中的表会同时修改其他表。回到我们订购单的例子中，当删除 Order 对象时，我们希望同时在数据库中删除关联的 LineItem 。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一些可用框架提供了上述服务，这些服务的通用名称是&lt;strong&gt;对象 / 关系映射（ object-relational mapping ， ORM ）&lt;/strong&gt;。在持久层使用 ORM 工具，可&lt;/p&gt;

&lt;p&gt;以节省数千行的代码和大量的开发时间。 ORM 工具能够把你的注意力从容易出错的 SQL 代码转向如何实现应用程序的真正需求。&lt;/p&gt;

&lt;h2 id=&#34;二-spring对orm框架的支持与扩展&#34;&gt;二、Spring对ORM框架的支持与扩展&lt;/h2&gt;

&lt;p&gt;Spring对多个持久化框架的集成提供了支持，这些框架包括
&lt;strong&gt;Hibernate&lt;/strong&gt;：可能是最常用的ORM框架，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;iBATIS&lt;/strong&gt;：Apache推出的一种轻量级的对象关系映射(ORM)框架&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java数据对象（ Java Data Objects ， JDO ）&lt;/strong&gt;： 是一个应用程序接口(API)，它是Java程序员能够间接地访问数据库，也就是说，不需使用直接的结构化查询语言(SQL)语句。JDO是作为Java数据库连接(JDBC)的一个补充来介绍的，而JDBC是一个支持使用SOL语句对流行的数据库程序进行访问的接口。有了 JDO，程序员就可以使用类来定义数据对象，然后支撑程序就会根据类的定义来管理对给定数据库的实际的数据访问了。　　&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java持久化 API （ Java Persistence API ， JPA ）&lt;/strong&gt;：JAVA 持久化API，是EJB 3.0 的专家推出，作为 JSR-220的一部分，简单点来说可以理解为是一个JAVA的标准规范，这个规范为对JAVA对象的持久化制定了一些标准的接口，也可以说，J&lt;strong&gt;PA&lt;/strong&gt;&lt;strong&gt;是一个标准的ORM（对象关系映射）规范，&lt;/strong&gt;提出这个规范，一方面是为了简化EJB中对于对象持久化的操作，另一方面，也希望通过制定统一规范，达到一统ORM标准的目的&lt;/p&gt;

&lt;p&gt;除了对这些框架提供集成支持，Spring还提供了额外的扩展增强服务：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;支持集成 Spring 声明式事务；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;透明的异常处理；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程安全的、轻量级的模板类；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DAO&lt;/strong&gt; &lt;strong&gt;支持类；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源管理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;三-jpa框架分析&#34;&gt;&lt;strong&gt;三、JPA框架分析&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;简单来说，JPA只是一套规范，用于统一对象持久化操作的标准。其架构组成如下：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_11_01_01.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;JPA的主要组成封装于&lt;strong&gt;Javax.persistence.jar&lt;/strong&gt;包中：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Persistence&lt;/strong&gt;&lt;strong&gt;：主要提供静态方法获取EntityManagerFactory实例&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EntityManagerFactory&lt;/strong&gt;&lt;strong&gt;：作为EntityMannage的工厂类，用于生产并管理多个EntityManager&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EntityManager&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;strong&gt;管理持久化对象，作为数据库操作的接口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EntityTransaction&lt;/strong&gt;&lt;strong&gt;：用于管理EntityManager操作，每个EntityManager对应一个EntityTransaction&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Query&lt;/strong&gt;&lt;strong&gt;：由JPA供应商提供，能够获取一个标准的关系对象并执行数据库操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Entity&lt;/strong&gt;&lt;strong&gt;：持久化对象/实体&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第十章:Spring和JDBC</title>
      <link>https://keep-zero.github.io/2019/spring_action10/</link>
      <pubDate>Sun, 01 Sep 2019 11:51:57 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action10/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据访问操作：初始化数据访问框架、打开连接、处理各种异常和关闭连接，任何一步出现异常都有可能导致损坏或删除企业数据库珍贵数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;详细文章请移步：&lt;a href=&#34;https://blog.csdn.net/Laiguanfu/article/details/88832458&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;CSDN-《Spring实战》-第十章:Spring和JDBC&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;一-spring-的数据访问哲学&#34;&gt;一、Spring 的数据访问哲学&lt;/h2&gt;

&lt;h3 id=&#34;①松耦合&#34;&gt;①松耦合&lt;/h3&gt;

&lt;p&gt;为了避免持久化的逻辑分散到应用的各个组件中，最好将数据访问的功能放到一个或多个专注于此项任务的组件中。这样的组件通常称为&lt;strong&gt;数据访问对象（ data access object ， DAO ）&lt;/strong&gt;或 &lt;strong&gt;Repositor&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了&lt;strong&gt;避免应用与特定的数据访问策略耦合在一起&lt;/strong&gt;，编写良好的 Repository 应该以接口的方式暴露功能。图 10.1 展现了设计数据访问层的合理方式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_10_01.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接口是实现松耦合代码的关键，并且应将其用于应用程序的各个层，而不仅仅是持久化层&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;②spring-数据访问异常&#34;&gt;&lt;strong&gt;②Spring&lt;/strong&gt; &lt;strong&gt;数据访问异常&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;JDBC&lt;/strong&gt;对于所有的数据访问问题都会抛出 SQLException ，可能导致抛出 SQLException 的常见问题包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;应用程序&lt;strong&gt;无法连接数据库&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;要执行的查询存在&lt;strong&gt;语法错误&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;查询中所使用的&lt;strong&gt;表和 / 或列不存在&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;试图插入或更新的数据&lt;strong&gt;违反了数据库约束&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见JDBC对于数据访问异常的处理十分粗糙，他并不会告诉你具体问题出现在哪里，而是讲所有问题都指向SQLException。所以很多持久化框架如Hibernate等都会提供自身的数据访问异常类，以供使用。但是如果我们在应用层次中引入了持久化框架的异常，很显然会紧紧的耦合在一起，违反了松耦合的约定。故而，Spring提供了自身一系列的异常类。&lt;/p&gt;

&lt;p&gt;然而，Spring所提供的异常都是&lt;strong&gt;继承自非检查型异常&lt;/strong&gt;，所以并不需要强制开发人员必须catch。&lt;/p&gt;

&lt;h2 id=&#34;二-spring-数据访问模板化&#34;&gt;&lt;strong&gt;二、Spring 数据访问模板化&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;模板方法模式（设计模式）：&lt;strong&gt;模板方法定义过程的主要框架，模板方法将过程中与特定实现相关的部分委托给接口，而这个接口的不同实现定义了过程中的具体行为&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Spring将数据访问分为可变（模板）和不可变（固定）两部分：&lt;strong&gt;模板（ template ）&lt;/strong&gt;和&lt;strong&gt;回调（ callback ）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_10_02.jpg&#34; alt=&#34;&#34; /&gt;
*   Spring 的模板类处理数据访问的固定部分 —— 事务控制、管理资源以及处理异常。
*   应用程序相关的数据访问 —— 语句、绑定参数以及整理结果集 —— 在回调的实现中处理。&lt;/p&gt;

&lt;p&gt;模板：Spring为了兼容多个持久化框架，提供了一系列的模板类&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jca.cci.core.CciTemplate&lt;/strong&gt;====JCA CCI 连接&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jdbc.core.JdbcTemplate&lt;/strong&gt;====JDBC 连接&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jdbc.core.namedparam.NamedParameterJdbcTemplate&lt;/strong&gt;====支持命名参数的 JDBC 连接
&lt;strong&gt;jdbc.core.simple.SimpleJdbcTemplate&lt;/strong&gt;====通过 Java 5 简化后的 JDBC 连接（ Spring 3.1 中已经废弃）
&lt;strong&gt;orm.hibernate3.HibernateTemplate&lt;/strong&gt;====Hibernate 3.x 以上的 Session
&lt;strong&gt;orm.ibatis.SqlMapClientTemplate&lt;/strong&gt;====iBATIS SqlMap 客户端
&lt;strong&gt;orm.jdo.JdoTemplate&lt;/strong&gt;====Java 数据对象（ Java Data Object ）实现
&lt;strong&gt;orm.jpa.JpaTemplate&lt;/strong&gt;====Java 持久化 API 的实体管理器&lt;/p&gt;

&lt;h2 id=&#34;三-spring-jdbc&#34;&gt;三、Spring+JDBC&lt;/h2&gt;

&lt;h3 id=&#34;ⅰ-配置数据源&#34;&gt;Ⅰ、配置数据源&lt;/h3&gt;

&lt;p&gt;Spring配置数据源依赖的第三方框架都提供了基本的DataSource接口。&lt;/p&gt;

&lt;p&gt;使用数据库连接池：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Apache Commons DBCP&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;c3p0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BoneCP&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Druid&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;DBCP连接池&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DBCP是 apache 上的一个 java 连接池项目，也是 tomcat 使用的连接池组件。&lt;/p&gt;

&lt;p&gt;依赖于BasicDataSource对象实现数据源配置&lt;/p&gt;

&lt;p&gt;BasicDataSource部分属性如下：
&lt;strong&gt;driverClassName&lt;/strong&gt;：&lt;strong&gt;数据库连接驱动名，如：com.mysql.jdbc.Driver&lt;/strong&gt;
&lt;strong&gt;url&lt;/strong&gt;：&lt;strong&gt;数据库连接地址，如:jdbc:mysql://localshot:3306/数据库名&lt;/strong&gt;
&lt;strong&gt;username&lt;/strong&gt;：&lt;strong&gt;数据库连接用户名&lt;/strong&gt;
&lt;strong&gt;passowrd&lt;/strong&gt;：&lt;strong&gt;数据库连接密码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先引入依赖包：commons-dbcp.jar和commons-pool.jar&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt; &amp;lt;!-- https://mvnrepository.com/artifact/commons-dbcp/commons-dbcp --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;commons-dbcp&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;commons-dbcp&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.4&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- https://mvnrepository.com/artifact/commons-pool/commons-pool --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;commons-pool&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;commons-pool&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.4&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入Spring-jdbc的支持--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入mysql数据连接驱动--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;两种方式配置DBCP连接池：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用注解配置实现&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①创建数据源配置类，定义数据源与JdbcTemplate操作模板&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class DataSourceConfig {
    /**
     * 数据源连接池
     */
    @Bean
    public DataSource dataSource(){
        BasicDataSource basicDataSource = new BasicDataSource();
        //设置驱动
        basicDataSource.setDriverClassName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;);
        //设置数据库路径
        basicDataSource.setUrl(&amp;quot;jdbc:mysql://localhost:3306/spring&amp;quot;);
        //设置数据库登录名
        basicDataSource.setUsername(&amp;quot;spring&amp;quot;);
        //设置数据库登录密码
        basicDataSource.setPassword(&amp;quot;spring&amp;quot;);
        //是否自动提交事务（默认为true）
        basicDataSource.setDefaultAutoCommit(true);
        return basicDataSource;
    }

    /**
     * Spring JdbcTemplate
     */
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②创建统一配置类，开启组件扫描，并将数据源配置类引入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ComponentScan(basePackages = {&amp;quot;com.my.spring&amp;quot;})
@Configuration
@Import(DataSourceConfig.class)
public class SystemConfig {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③创建数据库操作的Object对象和相应的Dao和Service类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//BaseBean.java
@Data
public class BaseBean {

    private Integer id;

    private String name;

    private Integer age;
}

//BaseDaoParent.java,系统内所有Dao的父类，继承自JdbcDaoSupport
@Component
public class BaseDaoParent extends JdbcDaoSupport {

    //注入DataSource
    @Autowired
    private DataSource dataSource;

    //因为JdbcDaoSupport的setDataSource方法是final修饰的，@Autowired注入失败，所以必须手动注入
    @PostConstruct
    private void initialize(){
        setDataSource(dataSource);
    }
}

//BaseDao.java
@Repository
public class BaseDao extends BaseDaoParent{

    /**
     * 保存一个记录
     * @param baseBean
     */
    public void save(BaseBean baseBean){
        this.getJdbcTemplate().update(&amp;quot;insert into basebean(name,age) values (&#39;&amp;quot;+baseBean.getName()+&amp;quot;&#39;,&amp;quot;+baseBean.getAge()+&amp;quot;)&amp;quot;);
    }

    /**
     * 获取所有bean记录
     * @return
     */
    public List&amp;lt;BaseBean&amp;gt; findAll(){
        RowMapper&amp;lt;BaseBean&amp;gt; rowMapper = new BeanPropertyRowMapper&amp;lt;&amp;gt;(BaseBean.class);
        return this.getJdbcTemplate().query(&amp;quot;select * from basebean&amp;quot;,rowMapper);
    }
}

//BaseService.java
public interface BaseService{
     /**
     * 保存一个记录
     * @param baseBean
     */
    void save(BaseBean baseBean);

    /**
     * 获取所有bean记录
     * @return
     */
    List&amp;lt;BaseBean&amp;gt; findAll();
}

//BaseServiceImpl.java
@Component
public class BaseServiceImpl implements BaseService {

    @Autowired
    private BaseDao baseDao;

    @Override
    public void save(BaseBean baseBean) {
        this.baseDao.save(baseBean);
    }

    @Override
    public List&amp;lt;BaseBean&amp;gt; findAll() {
        return this.baseDao.findAll();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;④编写测试类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = {SystemConfig.class})
public class DataSourceTest {

    @Autowired
    private BaseService baseService;

    /**
     *调用service方法存入对象
    */
    @Test
    public void testSaveBean(){
        BaseBean baseBean = new BaseBean();
        baseBean.setName(&amp;quot;test&amp;quot;);
        baseBean.setAge(15);
        this.baseService.save(baseBean);
    }

    /**
     *调用service方法获取所有记录
    */
   @Test
    public void testFindAll(){
        List&amp;lt;BaseBean&amp;gt; list = this.baseService.findAll();
        System.out.println(list.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑤创建数据库表&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for basebean
-- ----------------------------
DROP TABLE IF EXISTS `basebean`;
CREATE TABLE `basebean`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `age` int(10) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

SET FOREIGN_KEY_CHECKS = 1;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_10_03.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;⑥测试结果&lt;/p&gt;

&lt;p&gt;调用存入BaseBean，同时获取列表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[BaseBean(id=1, name=test, age=15)]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用xml配置实现&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;创建&lt;strong&gt;datasource.properties&lt;/strong&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;#指定数据库驱动
jdbc.driver = com.mysql.jdbc.Driver

#指定数据库url
jdbc.url = jdbc:mysql://localhost:3306/spring

#指定数据库用户
jdbc.username = spring

#指定数据库用户密码
jdbc.password = spring
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建application.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;

    &amp;lt;!-- 导入数据库资源文件 --&amp;gt;
    &amp;lt;context:property-placeholder location=&amp;quot;classpath:datasource.properties&amp;quot;/&amp;gt;
    &amp;lt;!--配置数据源--&amp;gt;
    &amp;lt;bean class=&amp;quot;org.apache.commons.dbcp.BasicDataSource&amp;quot; id=&amp;quot;dataSource&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--配置注入数据源--&amp;gt;
    &amp;lt;bean id = &amp;quot;baseDaoParent&amp;quot; class=&amp;quot;com.my.spring.dao.BaseDaoParent&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSource&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;baseDao&amp;quot; class=&amp;quot;com.my.spring.dao.BaseDao&amp;quot; parent=&amp;quot;baseDaoParent&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;baseService&amp;quot; class=&amp;quot;com.my.spring.service.impl.BaseServiceImpl&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;baseDao&amp;quot; ref=&amp;quot;baseDao&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭组件扫描，同时在全局配置中引入application.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
//@Import(DataSourceConfig.class)
@ImportResource(value = {&amp;quot;classpath:application.xml&amp;quot;})
public class SystemConfig {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[BaseBean(id=1, name=test, age=15), BaseBean(id=2, name=test, age=15)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;C3P0连接池&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C3P0是一个开源的JDBC&lt;a href=&#34;https://baike.baidu.com/item/%E8%BF%9E%E6%8E%A5%E6%B1%A0/1699713&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;连接池&lt;/a&gt;，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的&lt;a href=&#34;https://baike.baidu.com/item/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/3406069&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;开源项目&lt;/a&gt;有Hibernate，Spring等。&lt;/p&gt;

&lt;p&gt;依赖于&lt;strong&gt;ComboPooledDataSource&lt;/strong&gt; 对象实现配置，其基本属性如下：
&lt;strong&gt;driverclass&lt;/strong&gt;：&lt;strong&gt;数据库驱动类，比如MySQL为“com.mysql.jdbc.Driver”&lt;/strong&gt;
&lt;strong&gt;jdbcUrl&lt;/strong&gt;：&lt;strong&gt;数据库连接&lt;/strong&gt;
&lt;strong&gt;user&lt;/strong&gt;：&lt;strong&gt;登录数据库的账号&lt;/strong&gt;
&lt;strong&gt;password&lt;/strong&gt;：&lt;strong&gt;登录数据库的密码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用注解方式配置C3P0&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;①引入jar包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--引入c3p0支持--&amp;gt;
&amp;lt;!-- https://mvnrepository.com/artifact/c3p0/c3p0 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;c3p0&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;c3p0&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.9.1.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②创建数据源配置类，定义数据源与JdbcTemplate操作模板&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@PropertySource(value = {&amp;quot;classpath:datasource.properties&amp;quot;})//引入资源文件
public class DataSourceConfig {

    @Value(&amp;quot;${jdbc.driver}&amp;quot;)
    private String driver;

    @Value(&amp;quot;${jdbc.url}&amp;quot;)
    private String url;

    @Value(&amp;quot;${jdbc.username}&amp;quot;)
    private String userName;

    @Value(&amp;quot;${jdbc.password}&amp;quot;)
    private String password;

     /**
     * 数据源连接池
     */
    @Bean
    public DataSource dataSource() throws PropertyVetoException {
        ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();
        comboPooledDataSource.setDriverClass(driver);
        comboPooledDataSource.setJdbcUrl(url);
        comboPooledDataSource.setUser(userName);
        comboPooledDataSource.setPassword(password);
        return comboPooledDataSource;
    }

     /**
     * Spring JbdcTemplate
     */
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[BaseBean(id=1, name=test, age=15), BaseBean(id=2, name=test, age=15), BaseBean(id=3, name=test, age=15)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用XML配置C3P0&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;依旧使用application.xml，将数据源改为c3p0&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;

    &amp;lt;!-- 导入数据库资源文件 --&amp;gt;
    &amp;lt;context:property-placeholder location=&amp;quot;classpath:datasource.properties&amp;quot;/&amp;gt;
    &amp;lt;!--配置数据源DBCP--&amp;gt;
    &amp;lt;bean class=&amp;quot;org.apache.commons.dbcp.BasicDataSource&amp;quot; id=&amp;quot;dataSource&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--配置数据源C3P0--&amp;gt;
    &amp;lt;bean class=&amp;quot;com.mchange.v2.c3p0.ComboPooledDataSource&amp;quot; id=&amp;quot;dataSourceC3P0&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClass&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;jdbcUrl&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;user&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--配置注入数据源c3p0--&amp;gt;
    &amp;lt;bean id = &amp;quot;baseDaoParent&amp;quot; class=&amp;quot;com.my.spring.dao.BaseDaoParent&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSourceC3P0&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;baseDao&amp;quot; class=&amp;quot;com.my.spring.dao.BaseDao&amp;quot; parent=&amp;quot;baseDaoParent&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;baseService&amp;quot; class=&amp;quot;com.my.spring.service.impl.BaseServiceImpl&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;baseDao&amp;quot; ref=&amp;quot;baseDao&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将全局配置调整至读取xml模式，测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[BaseBean(id=1, name=test, age=15), BaseBean(id=2, name=test, age=15), BaseBean(id=3, name=test, age=15), BaseBean(id=4, name=test, age=15)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;BoneCP连接池&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个快速，开源的数据库连接池。帮你管理数据连接让你的应用程序能更快速地访问数据库。比C3P0和DBCP快25倍&lt;/p&gt;

&lt;p&gt;BoneCP依赖于&lt;strong&gt;com.jolbox.bonecp.BoneCPDataSource&lt;/strong&gt; 类，其主要属性如下：
&lt;strong&gt;driveClass&lt;/strong&gt;：&lt;strong&gt;数据库驱动&lt;/strong&gt;
&lt;strong&gt;jdbcUrl&lt;/strong&gt;：&lt;strong&gt;响应驱动的jdbcUrl&lt;/strong&gt;
&lt;strong&gt;username&lt;/strong&gt;：&lt;strong&gt;数据库的用户名&lt;/strong&gt;
&lt;strong&gt;password&lt;/strong&gt;：&lt;strong&gt;数据库的密码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用注解实现BoneCP配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;①引入依赖包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--引入BoneCP支持--&amp;gt;
&amp;lt;!-- https://mvnrepository.com/artifact/com.jolbox/bonecp --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.jolbox&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;bonecp&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.8.0.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②创建配置类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@PropertySource(value = {&amp;quot;classpath:datasource.properties&amp;quot;})//引入资源文件
public class DataSourceConfig {

    @Value(&amp;quot;${jdbc.driver}&amp;quot;)
    private String driver;

    @Value(&amp;quot;${jdbc.url}&amp;quot;)
    private String url;

    @Value(&amp;quot;${jdbc.username}&amp;quot;)
    private String userName;

    @Value(&amp;quot;${jdbc.password}&amp;quot;)
    private String password;

     /**
     * 数据源连接池
     */
    @Bean
    public DataSource dataSource(){
        BoneCPDataSource boneCPDataSource = new BoneCPDataSource();
        boneCPDataSource.setDriverClass(driver);
        boneCPDataSource.setJdbcUrl(url);
        boneCPDataSource.setUser(userName);
        boneCPDataSource.setPassword(password);
        return boneCPDataSource;
    }

     /**
     * Spring JbdcTemplate
     */
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[BaseBean(id=1, name=test, age=15), BaseBean(id=2, name=test, age=15), BaseBean(id=3, name=test, age=15), BaseBean(id=4, name=test, age=15), BaseBean(id=5, name=test, age=15)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用XML实现BoneCP配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;依旧使用application.xml，将数据源改为BoneCP&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;

    &amp;lt;!-- 导入数据库资源文件 --&amp;gt;
    &amp;lt;context:property-placeholder location=&amp;quot;classpath:datasource.properties&amp;quot;/&amp;gt;
    &amp;lt;!--配置数据源DBCP--&amp;gt;
    &amp;lt;bean class=&amp;quot;org.apache.commons.dbcp.BasicDataSource&amp;quot; id=&amp;quot;dataSource&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--配置数据源C3P0--&amp;gt;
    &amp;lt;bean class=&amp;quot;com.mchange.v2.c3p0.ComboPooledDataSource&amp;quot; id=&amp;quot;dataSourceC3P0&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClass&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;jdbcUrl&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;user&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

     &amp;lt;!--配置数据源BoneCP--&amp;gt;
    &amp;lt;bean class=&amp;quot;com.jolbox.bonecp.BoneCPDataSource&amp;quot; id=&amp;quot;dataSourceBoneCP&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClass&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;jdbcUrl&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;user&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--配置注入数据源BonCP--&amp;gt;
    &amp;lt;bean id = &amp;quot;baseDaoParent&amp;quot; class=&amp;quot;com.my.spring.dao.BaseDaoParent&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSourceBoneCP&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;baseDao&amp;quot; class=&amp;quot;com.my.spring.dao.BaseDao&amp;quot; parent=&amp;quot;baseDaoParent&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;baseService&amp;quot; class=&amp;quot;com.my.spring.service.impl.BaseServiceImpl&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;baseDao&amp;quot; ref=&amp;quot;baseDao&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[BaseBean(id=1, name=test, age=15), BaseBean(id=2, name=test, age=15), BaseBean(id=3, name=test, age=15), BaseBean(id=4, name=test, age=15), BaseBean(id=5, name=test, age=15), BaseBean(id=6, name=test, age=15)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Druid连接池&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、PROXOOL等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池&lt;/p&gt;

&lt;p&gt;Druid依赖于&lt;strong&gt;com.alibaba.druid.pool.DruidDataSource&lt;/strong&gt; 实现，其主要属性如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;name&lt;/strong&gt;:配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：&amp;rdquo;DataSource-&amp;rdquo; + System.identityHashCode(this)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;driverClassName&lt;/strong&gt;:这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)
&lt;strong&gt;jdbcUrl&lt;/strong&gt;:连接数据库的url，不同数据库不一样。
            例如： mysql&amp;mdash;&amp;mdash;- jdbc:mysql://10.20.153.104:3306/druid2
 oracle &amp;mdash;&amp;ndash;jdbc:oracle:thin:@10.20.149.85:1521:ocnauto
&lt;strong&gt;username&lt;/strong&gt;:连接数据库的用户名
&lt;strong&gt;password&lt;/strong&gt;:连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用注解实现Druid配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;引入支持依赖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.10&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②创建配置类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@PropertySource(value = {&amp;quot;classpath:datasource.properties&amp;quot;})//引入资源文件
public class DataSourceConfig {

    @Value(&amp;quot;${jdbc.driver}&amp;quot;)
    private String driver;

    @Value(&amp;quot;${jdbc.url}&amp;quot;)
    private String url;

    @Value(&amp;quot;${jdbc.username}&amp;quot;)
    private String userName;

    @Value(&amp;quot;${jdbc.password}&amp;quot;)
    private String password;

     /**
     * 数据源连接池
     */
    @Bean
    public DataSource dataSource(){
        DruidDataSource druidDataSource = new DruidDataSource();
        druidDataSource.setDriverClassName(driver);
        druidDataSource.setUrl(url);
        druidDataSource.setUsername(userName);
        druidDataSource.setPassword(password);
        return druidDataSource;
    }

     /**
     * Spring JbdcTemplate
     */
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[BaseBean(id=1, name=test, age=15), BaseBean(id=2, name=test, age=15), BaseBean(id=3, name=test, age=15), BaseBean(id=4, name=test, age=15), BaseBean(id=5, name=test, age=15), BaseBean(id=6, name=test, age=15), BaseBean(id=7, name=test, age=15)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用XML实现Druid配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用application.xml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
       xmlns:context=&amp;quot;http://www.springframework.org/schema/context&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;quot;&amp;gt;

    &amp;lt;!-- 导入数据库资源文件 --&amp;gt;
    &amp;lt;context:property-placeholder location=&amp;quot;classpath:datasource.properties&amp;quot;/&amp;gt;
    &amp;lt;!--配置数据源DBCP--&amp;gt;
    &amp;lt;bean class=&amp;quot;org.apache.commons.dbcp.BasicDataSource&amp;quot; id=&amp;quot;dataSource&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--配置数据源C3P0--&amp;gt;
    &amp;lt;bean class=&amp;quot;com.mchange.v2.c3p0.ComboPooledDataSource&amp;quot; id=&amp;quot;dataSourceC3P0&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClass&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;jdbcUrl&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;user&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

     &amp;lt;!--配置数据源BoneCP--&amp;gt;
    &amp;lt;bean class=&amp;quot;com.jolbox.bonecp.BoneCPDataSource&amp;quot; id=&amp;quot;dataSourceBoneCP&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClass&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;jdbcUrl&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;user&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--配置数据源Druid--&amp;gt;
    &amp;lt;bean class=&amp;quot;com.alibaba.druid.pool.DruidDataSource&amp;quot; id=&amp;quot;dataSourceDruid&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;driverClassName&amp;quot; value=&amp;quot;${jdbc.driver}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;url&amp;quot; value=&amp;quot;${jdbc.url}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;username&amp;quot; value=&amp;quot;${jdbc.username}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&amp;quot;password&amp;quot; value=&amp;quot;${jdbc.password}&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--配置注入数据源Druid--&amp;gt;
    &amp;lt;bean id = &amp;quot;baseDaoParent&amp;quot; class=&amp;quot;com.my.spring.dao.BaseDaoParent&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;dataSource&amp;quot; ref=&amp;quot;dataSourceDruid&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;baseDao&amp;quot; class=&amp;quot;com.my.spring.dao.BaseDao&amp;quot; parent=&amp;quot;baseDaoParent&amp;quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&amp;quot;baseService&amp;quot; class=&amp;quot;com.my.spring.service.impl.BaseServiceImpl&amp;quot;&amp;gt;
        &amp;lt;property name=&amp;quot;baseDao&amp;quot; ref=&amp;quot;baseDao&amp;quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;[BaseBean(id=1, name=test, age=15), BaseBean(id=2, name=test, age=15), BaseBean(id=3, name=test, age=15), BaseBean(id=4, name=test, age=15), BaseBean(id=5, name=test, age=15), BaseBean(id=6, name=test, age=15), BaseBean(id=7, name=test, age=15), BaseBean(id=8, name=test, age=15)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;四-spring-数据库操作&#34;&gt;&lt;strong&gt;四、Spring+数据库操作&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;如同往常我们想要实现一个简单的数据库操作，可能都会需要需要编写很多不必要的重复性代码，比如打开数据库，连接数据库，关闭数据库等，Spring JDBC使用JdbcTemplate封装重复操作&lt;/p&gt;

&lt;p&gt;上述代码已经展示了简单的JdbcTemplate操作。实际上我们有几种可能的方式去使用JdbcTemplate带给我们的便利&lt;/p&gt;

&lt;h3 id=&#34;ⅰ-继承jdbcdaosupport类&#34;&gt;Ⅰ、继承JdbcDaoSupport类&lt;/h3&gt;

&lt;p&gt;如同上述代码中所使用的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Component
public class BaseDaoParent extends JdbcDaoSupport {

    //注入DataSource
    @Autowired
    private DataSource dataSource;

    //因为JdbcDaoSupport的setDataSource方法是final修饰的，@Autowired注入失败，所以必须手动注入
    @PostConstruct
    private void initialize(){
        setDataSource(dataSource);
    }
}

@Repository
public class BaseDao extends BaseDaoParent{

    /**
     * 保存一个记录
     * @param baseBean
     */
    public void save(BaseBean baseBean){
        this.getJdbcTemplate().update(&amp;quot;insert into basebean(name,age) values (&#39;&amp;quot;+baseBean.getName()+&amp;quot;&#39;,&amp;quot;+baseBean.getAge()+&amp;quot;)&amp;quot;);
    }

    /**
     * 获取所有bean记录
     * @return
     */
    public List&amp;lt;BaseBean&amp;gt; findAll(){
        RowMapper&amp;lt;BaseBean&amp;gt; rowMapper = new BeanPropertyRowMapper&amp;lt;&amp;gt;(BaseBean.class);
        return this.getJdbcTemplate().query(&amp;quot;select * from basebean&amp;quot;,rowMapper);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到这种方式的限制是DataSource的注入过于繁琐，所以一般不使用这种方式&lt;/p&gt;

&lt;h3 id=&#34;ⅱ-直接引用jdbctemplate&#34;&gt;Ⅱ、直接引用JdbcTemplate&lt;/h3&gt;

&lt;p&gt;实际上，上述代码中的this.getJdbcTemplate()得到的也是上下文中的JdbcTemplate对象，我们可以选择直接注入JdbcTemplate进行使用，效果一样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class BaseDao{

    @Autowired
    private JdbcTemplate jdbcTemplate;

    /**
     * 保存一个记录
     * @param baseBean
     */
    public void save(BaseBean baseBean){
        this.jdbcTemplate.update(&amp;quot;insert into basebean(name,age) values (&#39;&amp;quot;+baseBean.getName()+&amp;quot;&#39;,&amp;quot;+baseBean.getAge()+&amp;quot;)&amp;quot;);
    }

    /**
     * 获取所有bean记录
     * @return
     */
    public List&amp;lt;BaseBean&amp;gt; findAll(){
        RowMapper&amp;lt;BaseBean&amp;gt; rowMapper = new BeanPropertyRowMapper&amp;lt;&amp;gt;(BaseBean.class);
        return this.jdbcTemplate.query(&amp;quot;select * from basebean&amp;quot;,rowMapper);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种做法的限制是应用代码与Spring JdbcTemplate的耦合性增强&lt;/p&gt;

&lt;h3 id=&#34;ⅲ-使用jdbcoperations类&#34;&gt;Ⅲ、使用JdbcOperations类&lt;/h3&gt;

&lt;p&gt;JdbcOperations 是一个接口，定义了 JdbcTemplate 所实现的操作。通过注入 JdbcOperations ，而不是具体的 JdbcTemplate ，能够保证dao 通过 JdbcOperations 接口达到与 JdbcTemplate 保持松耦合&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Repository
public class BaseDao{

    @Autowired
    private JdbcOperations jdbcOperations;

    /**
     * 保存一个记录
     * @param baseBean
     */
    public void save(BaseBean baseBean){
        this.jdbcOperations.update(&amp;quot;insert into basebean(name,age) values (&#39;&amp;quot;+baseBean.getName()+&amp;quot;&#39;,&amp;quot;+baseBean.getAge()+&amp;quot;)&amp;quot;);
    }

    /**
     * 获取所有bean记录
     * @return
     */
    public List&amp;lt;BaseBean&amp;gt; findAll(){
        RowMapper&amp;lt;BaseBean&amp;gt; rowMapper = new BeanPropertyRowMapper&amp;lt;&amp;gt;(BaseBean.class);
        return this.jdbcOperations.query(&amp;quot;select * from basebean&amp;quot;,rowMapper);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;五-spring与jdbctemplate&#34;&gt;&lt;strong&gt;五、Spring与JdbcTemplate&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;实际上，&lt;strong&gt;JdbcTemplate&lt;/strong&gt;所能做的远不止上述代码所展示。Spring中，有如下三种&lt;strong&gt;JdbcTemplate：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;JdbcTemplate&lt;/strong&gt; &lt;strong&gt;：最基本的 Spring JDBC 模板，这个模板支持简单的 JDBC 数据库访问功能以及基于索引参数的查询；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NamedParameterJdbcTemplate&lt;/strong&gt; &lt;strong&gt;：使用该模板类执行查询时可以将值以命名参数的形式绑定到 SQL 中，而不是使用简单的索引参&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SimpleJdbcTemplate&lt;/strong&gt; &lt;strong&gt;：该模板类利用 Java 5 的一些特性如自动装箱、泛型以及可变参数列表来简化 JDBC 模板的使用。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们采用最合适的jdbcOperations来学习&lt;strong&gt;JdbcTemplate&lt;/strong&gt;的功能&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JdbcTemplate主要提供以下五类方法：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;execute&lt;/strong&gt;方法：可以用于执行任何&lt;strong&gt;SQL&lt;/strong&gt;语句，一般用于执行&lt;strong&gt;DDL&lt;/strong&gt;语句&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;update&lt;/strong&gt;方法及&lt;strong&gt;batchUpdate&lt;/strong&gt;方法：&lt;strong&gt;update&lt;/strong&gt;方法用于执行新增、修改、删除等语句；&lt;strong&gt;batchUpdate&lt;/strong&gt;方法用于执行批处理相关语句**&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;query&lt;/strong&gt;方法及&lt;strong&gt;queryForXXX&lt;/strong&gt;方法：用于执行查询相关语句&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;call&lt;/strong&gt;方法：用于执行存储过程、函数相关语句&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中较为常用的有以下方法：&lt;/p&gt;

&lt;p&gt;①&lt;strong&gt;&lt;T&gt; T queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, @Nullable Object&amp;hellip; args) throws DataAccessException&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据语句和传参查询某个记录并将结果封装成对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final static String FIND_BASE_BEAN = &amp;quot;select * from basebean where id=?&amp;quot;;
public BaseBean findOne(Integer id){
    //目标对象映射
    RowMapper&amp;lt;BaseBean&amp;gt; rowMapper = new BeanPropertyRowMapper&amp;lt;&amp;gt;(BaseBean.class);
    //执行查询并返回目标对象
    return this.jdbcOperations.queryForObject(FIND_BASE_BEAN,rowMapper,id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②&lt;strong&gt;int update(String sql, @Nullable Object&amp;hellip; args) throws DataAccessException;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;更新或插入数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final static String INSERT_BASE_BEAN = &amp;quot;insert into basebean(name,age) values (?,?)&amp;quot;;
public void save(BaseBean baseBean){
    this.jdbcOperations.update(INSERT_BASE_BEAN,baseBean.getName(),baseBean.getAge());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③&lt;strong&gt;int update(String sql, @Nullable PreparedStatementSetter pss) throws DataAccessException;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用预编译设置更新或插入数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final static String INSERT_BASE_BEAN = &amp;quot;insert into basebean(name,age) values (?,?)&amp;quot;;
int count = this.jdbcOperations.update(INSERT_BASE_BEAN, new PreparedStatementSetter() {  
      @Override  
      public void setValues(PreparedStatement pstmt) throws SQLException {  
          pstmt.setObject(1, baseBean.getName());  
          pstmt.setObject(2, baseBean.getAge());
}}); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用命名参数Template实现功能，与使用简单的JdbcTemplate几乎完全相同：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public NamedParameterJdbcTemplate jdbcTemplate(DataSource dataSource) {
    return new NamedParameterJdbcTemplate(dataSource);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;strong&gt;NamedParameterJdbcTemplate&lt;/strong&gt;执行插入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//此处留下命名参数占位
private final static String INSERT_BASE_BEAN = &amp;quot;insert into basebean(name,age) values (:name,:age)&amp;quot;;

public void save(BaseBean baseBean){
    //封装命名参数值
    Map&amp;lt;String,Object&amp;gt; paramMap=new HashMap();
    paramMap.put(&amp;quot;name&amp;quot;,baseBean.getName()));
    paramMap.put(&amp;quot;age&amp;quot;, baseBean.getAge());

    this.jdbcOperations.update(INSERT_BASE_BEAN,paramMap);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;数据是应用程序的血液。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第九章:Spring Web应用安全（Spring Security）</title>
      <link>https://keep-zero.github.io/2019/spring_action09/</link>
      <pubDate>Sat, 31 Aug 2019 23:21:28 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action09/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安全性是绝大多数应用系统中的一个重要切面（ aspect ），之所以说是切面，是因为&lt;strong&gt;安全性是超越应用程序功能的一个关注点&lt;/strong&gt;。应用系统的绝大部分内容都不应该参与到与自己相关的安全性处理中。尽管我们可以直接在应用程序中编写安全性功能相关的代码（这种情况并不少见），但更好的方式还是将安全性相关的关注点与应用程序本身的关注点进行分离&lt;/p&gt;

&lt;h2 id=&#34;一-什么是spring-security&#34;&gt;一、什么是Spring Security?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;一种基于 Spring AOP 和 Servlet 规范中的 Filter 实现的安全框架&lt;/strong&gt;。 Spring Security 提供了完整的安全性解决方案，它能够在 &lt;strong&gt;Web 请求级别和方法调用级别处理身份认证和授权&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Spring Security 从两个角度来解决安全性问题。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;它使用 Servlet 规范中的 &lt;strong&gt;Filter&lt;/strong&gt; 保护 Web 请求并限制 URL 级别的访问。&lt;/li&gt;
&lt;li&gt;Spring Security 还能够使用 Spring AOP 保护方法调用 —— 借助于对象代理和使用通知，能够确保&lt;strong&gt;只有具备适当权限的用户才能访问安全保护的方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Spring Security的核心是 &lt;strong&gt;用户认证（Authentication）和用户授权（Authorization）&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;二-spring-security基本组成&#34;&gt;二、Spring Security基本组成&lt;/h2&gt;

&lt;p&gt;Spring Security 被分成了 11 个模块
ACL:支持通过访问控制列表（ access control list ， ACL ）为域对象提供安全性
切面（ Aspects ）:一个很小的模块，当使用 Spring Security 注解时，会使用基于 AspectJ 的切面，而不是使用标准的 Spring AOP
CAS 客户端（ CAS Client ）：提供与 Jasig 的中心认证服务（ Central Authentication Service ， CAS ）进行集成的功能
&lt;strong&gt;配置（ Configuration ）&lt;/strong&gt;:&lt;strong&gt;包含通过 XML 和 Java 配置 Spring Security 的功能支持&lt;/strong&gt;
&lt;strong&gt;核心（ Core ）&lt;/strong&gt;:&lt;strong&gt;提供 Spring Security 基本库&lt;/strong&gt;
加密（ Cryptography ）:提供了加密和密码编码的功能
LDAP:支持基于 LDAP 进行认证
OpenID:支持使用 OpenID 进行集中式认证
Remoting:提供了对 Spring Remoting 的支持
标签库（ Tag Library ）:Spring Security 的 JSP 标签库
&lt;strong&gt;Web&lt;/strong&gt;:&lt;strong&gt;提供了 Spring Security 基于 Filter 的 Web 安全性支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个基本的Spring Security应用至少包括Core和Configuration模块，当涉及到Web应用时，还需要包含Web模块。&lt;/p&gt;

&lt;h2 id=&#34;三-spring-security使用&#34;&gt;三、Spring Security使用&lt;/h2&gt;

&lt;p&gt;pom文件中引入基本的Spring Security及Spring MVC所需要的包&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;maven.compiler.source&amp;gt;1.7&amp;lt;/maven.compiler.source&amp;gt;
    &amp;lt;maven.compiler.target&amp;gt;1.7&amp;lt;/maven.compiler.target&amp;gt;
    &amp;lt;spring.security.version&amp;gt;5.1.3.RELEASE&amp;lt;/spring.security.version&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入Servlet支持--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- jstl --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;jstl&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--个人封装的一个模块，可有可无，不影响功能实现--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.my.spring&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;com.m.spring.common&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入Spring支持--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-aop&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.8.13&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入Spring MVC支持--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--引入Spring Security支持--&amp;gt;
    &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-core --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-security-core&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.security.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-web --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-security-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.security.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework.security/spring-security-config --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-security-config&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${spring.security.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;①配置SpringMVC默认&lt;strong&gt;DispatcherServlet&lt;/strong&gt;类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    /*AbstractAnnotationConfigDispatcherServletInitializer 会同时创
    建 DispatcherServlet 和 ContextLoaderListener 。 GetServlet-ConfigClasses() 方法返回的带有 @Configuration 注解的
    类将会用来定义 DispatcherServlet 应用上下文中的 bean 。 getRootConfigClasses() 方法返回的带有 @Configuration 注解的类将
    会用来配置 ContextLoaderListener 创建的应用上下文中的 bean 。*/

    @Override
    protected Class&amp;lt;?&amp;gt;[] getRootConfigClasses() {
        return new Class[]{RootConfig.class};
    }

    @Override
    protected Class&amp;lt;?&amp;gt;[] getServletConfigClasses() {
        return new Class[]{WebConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        logger.debug(&amp;quot;DispatcherServlet获取匹配的前端控制器。。。。。。&amp;quot;);
        return new String[]{&amp;quot;/&amp;quot;};
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②创建Spring Security的DelegatingFilterProxy,自动加载springSecurityFilterChain&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 *  拦截发往应用中的请求，并将请求委托给 ID 为 springSecurityFilterChain的bean
 *  springSecurityFilterChain 本身是另一个特殊的 Filter,它也被称为 FilterChainProxy.它可以链接任意一个或多个其他的 Filter。
 *  Spring Security 依赖一系列 Servlet Filter 来提供不同的安全特性。
 **/
public class SpringSecurityInitializer extends AbstractSecurityWebApplicationInitializer {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③配置SpringMVC的根配置和Web配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@ComponentScan(basePackages ={&amp;quot;com.my.spring&amp;quot;},excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION,value = {EnableWebMvc.class})})
public class RootConfig {
}

@EnableWebMvc
@Configuration
@ComponentScan(basePackages = {&amp;quot;com.my.spring.controller&amp;quot;})
@Import(SecurityConfig.class)//引入Spring Security的配置
public class WebConfig extends WebMvcConfigurationSupport {

    /**
     * 定义一个视图解析器
     *
     * @return org.springframework.web.servlet.ViewResolver
     *
     * @author lai.guanfu 2019/3/5
     * @version 1.0
     **/
    @Bean
    public ViewResolver viewResolver(){
        InternalResourceViewResolver resourceViewResolver = new InternalResourceViewResolver();
        resourceViewResolver.setPrefix(&amp;quot;/WEB-INF/view/&amp;quot;);
        resourceViewResolver.setSuffix(&amp;quot;.jsp&amp;quot;);
        resourceViewResolver.setExposeContextBeansAsAttributes(true);
        resourceViewResolver.setViewClass(JstlView.class);
        return resourceViewResolver;
    }

    @Override
    protected void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;④SecurityConfig.java:开启Spring Security并配置基本拦截和用户信息,增加两个用户&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableWebSecurity//启用Spring Security
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    /**
     * 设置拦截路径
     * @param http
     * @throws Exception
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                //配置拦截路径以及认证通过的身份，此处拦截任意/admin/**路径，必须以ADMIN身份登录
                .antMatchers(&amp;quot;/admin/**&amp;quot;).access(&amp;quot;hasRole(&#39;ROLE_ADMIN&#39;)&amp;quot;)
                //配置拦截路径以及认证通过的身份，此处指定只有访问/dba/**的GET请求会被拦截认证，必须以DBA或者ADMIN的身份登录
                .antMatchers(HttpMethod.GET,&amp;quot;/dba/**&amp;quot;).access(&amp;quot;hasAnyRole(&#39;ROLE_DBA&#39;,&#39;ROLE_ADMIN&#39;)&amp;quot;)
                //表明除了上述路径需要拦截认证外，其余路径全部不进行认证
                .anyRequest().permitAll()
                //add()方法用于连接各种配置指令
                .and() 
                //当重写configure(HttpSecurity http)方法后，将失去Spring Security的默认登录页，可以使用formLogin()重新启用
                .formLogin();
    }

    /**
     * 使用内存设置基本人物信息
     * @param auth
     * @throws Exception
     */
    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        //使用内存添加用户名及登陆密码和身份，使用指定编码器对密码进行编码
        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(&amp;quot;admin&amp;quot;).password(new BCryptPasswordEncoder().encode(&amp;quot;123456&amp;quot;)).roles(&amp;quot;ADMIN&amp;quot;);
        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(&amp;quot;dba&amp;quot;).password(new BCryptPasswordEncoder().encode(&amp;quot;123456&amp;quot;)).roles(&amp;quot;DBA&amp;quot;);

        //Spring Security 5.0之前的写法，5.0之后，如果没有指定密码编码器，将会报There is no PasswordEncoder mapped for the id &amp;quot;null&amp;quot;的错
        /*auth.inMemoryAuthentication().withUser(&amp;quot;admin&amp;quot;).password(&amp;quot;123456&amp;quot;).roles(&amp;quot;ADMIN&amp;quot;);
        auth.inMemoryAuthentication().withUser(&amp;quot;dba&amp;quot;).password(&amp;quot;123456&amp;quot;).roles(&amp;quot;DBA&amp;quot;);*/
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑤编写controller方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class MyController{

    //不需要权限的路径
    @RequestMapping(value = {&amp;quot;/&amp;quot;,&amp;quot;/welcome**&amp;quot;},method = RequestMethod.GET)
    public ModelAndView toWelcomePage(){
        ModelAndView model = new ModelAndView();
        model.addObject(&amp;quot;title&amp;quot;,&amp;quot;Spring Security Welcome Page!!&amp;quot;);
        model.addObject(&amp;quot;message&amp;quot;,&amp;quot;Hello World&amp;quot;);
        model.setViewName(&amp;quot;welcome&amp;quot;);
        return model;
    }

    //需要ADMIN角色权限
    @RequestMapping(value = {&amp;quot;/admin**&amp;quot;},method = RequestMethod.GET)
    public ModelAndView toAdminPage(){
        ModelAndView model = new ModelAndView();
        model.addObject(&amp;quot;title&amp;quot;,&amp;quot;Spring Security Admin Page!!&amp;quot;);
        model.addObject(&amp;quot;message&amp;quot;,&amp;quot;Hello World&amp;quot;);
        model.setViewName(&amp;quot;admin&amp;quot;);
        return model;
    }

    //需要DBA或者ADMIN权限
    @RequestMapping(value = {&amp;quot;/dba**&amp;quot;},method = RequestMethod.GET)
    public ModelAndView toDBAPage(){
        ModelAndView model = new ModelAndView();
        model.addObject(&amp;quot;title&amp;quot;,&amp;quot;Spring Security DBA Admin Page!!&amp;quot;);
        model.addObject(&amp;quot;message&amp;quot;,&amp;quot;Hello World&amp;quot;);
        model.setViewName(&amp;quot;dba&amp;quot;);
        return model;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑥编写视图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;welcome.jsp

&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
&amp;lt;%@ page isELIgnored=&amp;quot;false&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;欢迎页&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;&amp;lt;c:out value=&amp;quot;${title}&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt;&amp;lt;/h1&amp;gt;
    &amp;lt;hr&amp;gt;
    &amp;lt;h3&amp;gt;&amp;lt;c:out value=&amp;quot;${message}&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt;&amp;lt;/h3&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

admin.jsp

&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
&amp;lt;%@ page isELIgnored=&amp;quot;false&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;管理员页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Title : ${title}&amp;lt;/h1&amp;gt;
&amp;lt;h1&amp;gt;Message : ${message}&amp;lt;/h1&amp;gt;

&amp;lt;!--获取用户信息--&amp;gt;
&amp;lt;c:if test=&amp;quot;${pageContext.request.userPrincipal.name != null}&amp;quot;&amp;gt;
    &amp;lt;h2&amp;gt;Welcome : ${pageContext.request.userPrincipal.name}
        | &amp;lt;a href=&amp;quot;&amp;lt;c:url value=&amp;quot;/logout&amp;quot; /&amp;gt;&amp;quot; &amp;gt; Logout&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;
&amp;lt;/c:if&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

dba.jsp

&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
&amp;lt;%@ page isELIgnored=&amp;quot;false&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;h1&amp;gt;Title : ${title}&amp;lt;/h1&amp;gt;
    &amp;lt;h1&amp;gt;Message : ${message}&amp;lt;/h1&amp;gt;

    &amp;lt;c:if test=&amp;quot;${pageContext.request.userPrincipal.name != null}&amp;quot;&amp;gt;
        &amp;lt;h2&amp;gt;Welcome : ${pageContext.request.userPrincipal.name}
            | &amp;lt;a href=&amp;quot;&amp;lt;c:url value=&amp;quot;/logout&amp;quot; /&amp;gt;&amp;quot; &amp;gt; Logout&amp;lt;/a&amp;gt;&amp;lt;/h2&amp;gt;
    &amp;lt;/c:if&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动服务器，浏览器校验如下：&lt;/p&gt;

&lt;p&gt;访问welcome，无登陆身份状态可访问&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_09_01.jpg&#34; alt=&#34;&#34; /&gt;
访问/admin,自动跳转到Spring Security提供的登录页
&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_09_02.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;输入错误登录名或密码时会显示错误&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_09_03.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;使用对/admin无权限的用户登录，会显示403页面&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_09_04.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_09_05.jpg&#34; alt=&#34;&#34; /&gt;
使用admin进行登陆，正常进入并获取到登陆用户的信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_09_06.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_09_07.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;访问/dba，从上面代码中，我们知道，对于/dba路径的请求，使用ADMIN和DBA角色访问都是允许的，&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_09_08.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;测试完成，那么，Spring Security究竟是怎么实现拦截的呢？&lt;/p&gt;

&lt;h2 id=&#34;四-spring-security-原理分析&#34;&gt;四、Spring Security 原理分析&lt;/h2&gt;

&lt;p&gt;实际上，Spring Security通过一层层基于Servlet的过滤器Filter对请求和方法调用的拦截过滤，从而实现用户身份验证和用户授权。&lt;/p&gt;

&lt;p&gt;我们先来分析一下Speing Security的运转流程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_09_09.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，Speing Security的核心组件是一个名为&lt;strong&gt;DelegatingFilterProxy&lt;/strong&gt;的过滤器，它将一系列的过滤器集合成FilterChain链条，进行层层过滤实现用户身份认证及授权。&lt;/p&gt;

&lt;p&gt;从Demo代码中可以看到Spring Security的几个核心类和接口以及注解，以下一一分析：&lt;/p&gt;

&lt;p&gt;①&lt;strong&gt;DelegatingFilterProxy&lt;/strong&gt;类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DelegatingFilterProxy extends GenericFilterBean {
    。。。
    //根据名称创建一个过滤器实例
    public DelegatingFilterProxy(String targetBeanName) {
       this(targetBeanName, null);
    }

    public DelegatingFilterProxy(String targetBeanName, @Nullable WebApplicationContext wac) {
       Assert.hasText(targetBeanName, &amp;quot;Target Filter bean name must not be null or empty&amp;quot;);
       this.setTargetBeanName(targetBeanName);
       this.webApplicationContext = wac;
       if (wac != null) {
          this.setEnvironment(wac.getEnvironment());
       }
    }

    //初始化（获取过滤器实例）
    protected Filter initDelegate(WebApplicationContext wac) throws ServletException {
       String targetBeanName = getTargetBeanName();
       Assert.state(targetBeanName != null, &amp;quot;No target bean name set&amp;quot;);
       Filter delegate = wac.getBean(targetBeanName, Filter.class);
       if (isTargetFilterLifecycle()) {
          delegate.init(getFilterConfig());
       }
       return delegate;
    }

    //进入过滤操作
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)
          throws ServletException, IOException {

       // Lazily initialize the delegate if necessary.------delegate判空填充操作
       Filter delegateToUse = this.delegate;
       if (delegateToUse == null) {
          synchronized (this.delegateMonitor) {
             delegateToUse = this.delegate;
             if (delegateToUse == null) {
                WebApplicationContext wac = findWebApplicationContext();
                if (wac == null) {
                   throw new IllegalStateException(&amp;quot;No WebApplicationContext found: &amp;quot; +
                         &amp;quot;no ContextLoaderListener or DispatcherServlet registered?&amp;quot;);
                }
                delegateToUse = initDelegate(wac);
             }
             this.delegate = delegateToUse;
          }
       }

       // Let the delegate perform the actual doFilter operation.执行真正的过滤
       invokeDelegate(delegateToUse, request, response, filterChain);
    }

    //真正执行过滤
    protected void invokeDelegate(
      Filter delegate, ServletRequest request, ServletResponse response, FilterChain filterChain)
      throws ServletException, IOException {
        //执行目标过滤方法，而不是本类内的过滤方法，相当于将过滤委派给实例
       delegate.doFilter(request, response, filterChain);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，DelegatingFilterProxy实际上就是一个Filter，只不过他并不会直接执行过滤操作，而是将过滤操作委托给过滤链条&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_09_10.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;②&lt;strong&gt;AbstractSecurityWebApplicationInitializer&lt;/strong&gt;类&lt;/p&gt;

&lt;p&gt;关键源代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class AbstractSecurityWebApplicationInitializer
      implements WebApplicationInitializer {

   private static final String SERVLET_CONTEXT_PREFIX = &amp;quot;org.springframework.web.servlet.FrameworkServlet.CONTEXT.&amp;quot;;

   public static final String DEFAULT_FILTER_NAME = &amp;quot;springSecurityFilterChain&amp;quot;;

   private final Class&amp;lt;?&amp;gt;[] configurationClasses;

   protected AbstractSecurityWebApplicationInitializer() {
      this.configurationClasses = null;
   }

   protected AbstractSecurityWebApplicationInitializer(
         Class&amp;lt;?&amp;gt;... configurationClasses) {
      this.configurationClasses = configurationClasses;
   }

    //初始执行，生成名为springSecurityFilterChain的Bean，是一个DelegatingFilterProxy的实例
   public final void onStartup(ServletContext servletContext) throws ServletException {
      beforeSpringSecurityFilterChain(servletContext);
      if (this.configurationClasses != null) {
         AnnotationConfigWebApplicationContext rootAppContext = new AnnotationConfigWebApplicationContext();
         rootAppContext.register(this.configurationClasses);
         servletContext.addListener(new ContextLoaderListener(rootAppContext));
      }
      if (enableHttpSessionEventPublisher()) {
         servletContext.addListener(
               &amp;quot;org.springframework.security.web.session.HttpSessionEventPublisher&amp;quot;);
      }
      servletContext.setSessionTrackingModes(getSessionTrackingModes());
      //生成springSecurityFilterChain
      insertSpringSecurityFilterChain(servletContext);
      afterSpringSecurityFilterChain(servletContext);
   }

   /**
    * 注册springSecurityFilterChain，Spring Security的过滤器链条
    * Registers the springSecurityFilterChain 
    */
   private void insertSpringSecurityFilterChain(ServletContext servletContext) {
      String filterName = DEFAULT_FILTER_NAME;
      //关键代码
      DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy(filterName);
      //获取应用上下文配置中的属性并置入springSecurityFilterChain中
      String contextAttribute = getWebApplicationContextAttribute();
      if (contextAttribute != null) {
         springSecurityFilterChain.setContextAttribute(contextAttribute);
      }

      //注册过滤器链条
      registerFilter(servletContext, true, filterName, springSecurityFilterChain);
   }

   //注册过滤器链条
   private void registerFilters(ServletContext servletContext,boolean insertBeforeOtherFilters, Filter... filters) {
       Assert.notEmpty(filters, &amp;quot;filters cannot be null or empty&amp;quot;);
       for (Filter filter : filters) {
           if (filter == null) {
             throw new IllegalArgumentException(&amp;quot;filters cannot contain null values. Got &amp;quot;+ Arrays.asList(filters));
           }
           String filterName = Conventions.getVariableName(filter);
           registerFilter(servletContext, insertBeforeOtherFilters, filterName, filter);
       }
    }

    //注册过滤器
    private final void registerFilter(ServletContext servletContext,boolean insertBeforeOtherFilters, String filterName, Filter filter) {
       Dynamic registration = servletContext.addFilter(filterName, filter);
       if (registration == null) {
          throw new IllegalStateException(&amp;quot;Duplicate Filter registration for &#39;&amp;quot; + filterName+ &amp;quot;&#39;. Check to ensure the Filter is only configured once.&amp;quot;);
       }
       registration.setAsyncSupported(isAsyncSecuritySupported());
       EnumSet&amp;lt;DispatcherType&amp;gt; dispatcherTypes = getSecurityDispatcherTypes();
       registration.addMappingForUrlPatterns(dispatcherTypes, !insertBeforeOtherFilters,
         &amp;quot;/*&amp;quot;);
    }

   //供开发者自定义Filter 
   protected final void insertFilters(ServletContext servletContext, Filter... filters) {
      registerFilters(servletContext, true, filters);
   }

   //供开发者自定义Filter 
   protected final void appendFilters(ServletContext servletContext, Filter... filters) {
      registerFilters(servletContext, false, filters);
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;AbstractSecurityWebApplicationInitializer&lt;/strong&gt;实现了&lt;strong&gt;WebWebApplicationInitializer&lt;/strong&gt;，所以在应用启动的时候是可以被Spring装配并进行初始化的，在进行初始化的过程中，AbstractSecurityWebApplicationInitializer读取配置并生成一个名为&lt;strong&gt;springSecurityFilterChain&lt;/strong&gt;的Bean，是&lt;strong&gt;DelegatingFilterProxy&lt;/strong&gt;的实例，并将配置中所定义的过滤链条进行注入&lt;/p&gt;

&lt;p&gt;AbstractSecurityWebApplicationInitializer还提供了两个方法供开发者自定义过滤器：&lt;strong&gt;insertFilters(ServletContext servletContext, Filter&amp;hellip; filters）和appendFilters(ServletContext servletContext, Filter&amp;hellip; filters)&lt;/strong&gt;，但是一般来说我们不会用到，除非我们希望可以自定义过滤逻辑。&lt;/p&gt;

&lt;p&gt;③&lt;strong&gt;WebSecurityConfigurerAdapter类&amp;amp;&amp;amp;@EnableWebSecurity注解&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当创建了一个继承了AbstractSecurityWebApplicationInitializer的初始化类后，我们只需再创建一个配置类继承&lt;strong&gt;WebSecurityConfigurerAdapter&lt;/strong&gt;类且标注&lt;strong&gt;@EnableWebSecurity&lt;/strong&gt;注解即可开启Web 的Security服务了。但是此时的应用是封闭的，因为没有配置任何的用户身份，也没有配置任何的过滤路径规则，应用默认封锁所有路径。&lt;/p&gt;

&lt;p&gt;那么，应该如何配置用户身份和过滤器规则呢？&lt;/p&gt;

&lt;p&gt;WebSecurityConfigurerAdapter类中有几个关键方法可以重载&lt;/p&gt;

&lt;p&gt;configure(HttpSecurity):配置拦截模式
configure(AuthenticationManagerBuilder):配置用户信息
configure(WebSecurity):配置Spring Security的Filter链&lt;/p&gt;

&lt;p&gt;在进行配置分析之前，我们需要先了解几个类：（摘自：&lt;a href=&#34;https://www.cnblogs.com/xz816111/p/8528896.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.cnblogs.com/xz816111/p/8528896.html&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Authentication&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;是一个接口，用来表示用户认证信息，在用户登录认证之前相关信息会封装为一个&lt;strong&gt;Authentication&lt;/strong&gt;具体实现类的对象，在登录认证成功之后又会生成一个信息更全面，包含用户权限等信息的Authentication对象，然后把它保存 &lt;strong&gt;SecurityContextHolder&lt;/strong&gt;所持有的&lt;strong&gt;SecurityContext&lt;/strong&gt;中，供后续的程序进行调用，如访问权限的鉴定等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AuthenticationManager&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用来做验证的最主要的接口为&lt;strong&gt;AuthenticationManager&lt;/strong&gt;，这个接口只有一个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface AuthenticationManager {
  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中authenticate()方法运行后可能会有三种情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;验证成功，返回一个带有用户信息的Authentication。&lt;/li&gt;
&lt;li&gt;验证失败，抛出一个AuthenticationException异常。&lt;/li&gt;
&lt;li&gt;无法判断，返回null。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;ProviderManager&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ProviderManager&lt;/strong&gt;是上面的&lt;strong&gt;AuthenticationManager&lt;/strong&gt;最常见的实现，&lt;strong&gt;它不自己处理验证，而是将验证委托给其所配置的AuthenticationProvider列表&lt;/strong&gt;，&lt;strong&gt;然后会依次调用每一个 AuthenticationProvider进行认证&lt;/strong&gt;，这个过程中只要有一个AuthenticationProvider验证成功，就不会再继续做更多验证，会直接以该认证结果作为&lt;strong&gt;ProviderManager&lt;/strong&gt;的认证结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ProviderManager implements AuthenticationManager, MessageSourceAware,
      InitializingBean {

   private static final Log logger = LogFactory.getLog(ProviderManager.class);

   private AuthenticationEventPublisher eventPublisher = new NullEventPublisher();
   private List&amp;lt;AuthenticationProvider&amp;gt; providers = Collections.emptyList();
   protected MessageSourceAccessor messages = SpringSecurityMessageSource.getAccessor();
   private AuthenticationManager parent;
   private boolean eraseCredentialsAfterAuthentication = true;

   public ProviderManager(List&amp;lt;AuthenticationProvider&amp;gt; providers) {
      this(providers, null);
   }

   public ProviderManager(List&amp;lt;AuthenticationProvider&amp;gt; providers,
         AuthenticationManager parent) {
      Assert.notNull(providers, &amp;quot;providers list cannot be null&amp;quot;);
      this.providers = providers;
      this.parent = parent;
      checkState();
   }

   public void afterPropertiesSet() throws Exception {
      checkState();
   }

   private void checkState() {
      if (parent == null &amp;amp;&amp;amp; providers.isEmpty()) {
         throw new IllegalArgumentException(
               &amp;quot;A parent AuthenticationManager or a list &amp;quot;
                     + &amp;quot;of AuthenticationProviders is required&amp;quot;);
      }
   }

   //执行认证
   public Authentication authenticate(Authentication authentication)
         throws AuthenticationException {
      Class&amp;lt;? extends Authentication&amp;gt; toTest = authentication.getClass();
      AuthenticationException lastException = null;
      AuthenticationException parentException = null;
      Authentication result = null;
      Authentication parentResult = null;
      boolean debug = logger.isDebugEnabled();
      //并不直接验证，而是调用其provider列表进行验证，只要有一个验证通过，则通过
      for (AuthenticationProvider provider : getProviders()) {
         if (!provider.supports(toTest)) {
            continue;
         }

         if (debug) {
            logger.debug(&amp;quot;Authentication attempt using &amp;quot;
                  + provider.getClass().getName());
         }

         try {
            result = provider.authenticate(authentication);

            if (result != null) {
               copyDetails(authentication, result);
               break;
            }
         }
         catch (AccountStatusException e) {
            prepareException(e, authentication);
            // SEC-546: Avoid polling additional providers if auth failure is due to
            // invalid account status
            throw e;
         }
         catch (InternalAuthenticationServiceException e) {
            prepareException(e, authentication);
            throw e;
         }
         catch (AuthenticationException e) {
            lastException = e;
         }
      }

      if (result == null &amp;amp;&amp;amp; parent != null) {
         // Allow the parent to try.
         try {
            result = parentResult = parent.authenticate(authentication);
         }
         catch (ProviderNotFoundException e) {
            // ignore as we will throw below if no other exception occurred prior to
            // calling parent and the parent
            // may throw ProviderNotFound even though a provider in the child already
            // handled the request
         }
         catch (AuthenticationException e) {
            lastException = parentException = e;
         }
      }

      if (result != null) {
         if (eraseCredentialsAfterAuthentication
               &amp;amp;&amp;amp; (result instanceof CredentialsContainer)) {
            // Authentication is complete. Remove credentials and other secret data
            // from authentication
            ((CredentialsContainer) result).eraseCredentials();
         }

         // If the parent AuthenticationManager was attempted and successful than it will publish an AuthenticationSuccessEvent
         // This check prevents a duplicate AuthenticationSuccessEvent if the parent AuthenticationManager already published it
         if (parentResult == null) {
            eventPublisher.publishAuthenticationSuccess(result);
         }
         return result;
      }

      // Parent was null, or didn&#39;t authenticate (or throw an exception).

      if (lastException == null) {
         lastException = new ProviderNotFoundException(messages.getMessage(
               &amp;quot;ProviderManager.providerNotFound&amp;quot;,
               new Object[] { toTest.getName() },
               &amp;quot;No AuthenticationProvider found for {0}&amp;quot;));
      }

      // If the parent AuthenticationManager was attempted and failed than it will publish an AbstractAuthenticationFailureEvent
      // This check prevents a duplicate AbstractAuthenticationFailureEvent if the parent AuthenticationManager already published it
      if (parentException == null) {
         prepareException(lastException, authentication);
      }

      throw lastException;
   }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;了解完基本的关键类，我们开始看一下配置的技巧：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;配置用户信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两种方式：&lt;/p&gt;

&lt;p&gt;Ⅰ、&lt;strong&gt;自定义方法将用户信息存入内存&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * 使用内存设置基本人物信息
 * @param auth
 * @throws Exception
 */
@Autowired
public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
      //使用内存添加用户名及登陆密码和身份，使用指定编码器对密码进行编码
      auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(&amp;quot;admin&amp;quot;).password(new BCryptPasswordEncoder().encode(&amp;quot;123456&amp;quot;)).roles(&amp;quot;ADMIN&amp;quot;);
      auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(&amp;quot;dba&amp;quot;).password(new BCryptPasswordEncoder().encode(&amp;quot;123456&amp;quot;)).roles(&amp;quot;DBA&amp;quot;);

      //Spring Security 5.0之前的写法，5.0之后，如果没有指定密码编码器，将会报There is no PasswordEncoder mapped for the id &amp;quot;null&amp;quot;的错
        /*auth.inMemoryAuthentication().withUser(&amp;quot;admin&amp;quot;).password(&amp;quot;123456&amp;quot;).roles(&amp;quot;ADMIN&amp;quot;);
      auth.inMemoryAuthentication().withUser(&amp;quot;dba&amp;quot;).password(&amp;quot;123456&amp;quot;).roles(&amp;quot;DBA&amp;quot;);*/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ⅱ、&lt;strong&gt;重载configure(AuthenticationManagerBuilder)方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception
{
    //使用内存添加用户名及登陆密码和身份，使用指定编码器对密码进行编码
    auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(&amp;quot;admin&amp;quot;).password(new BCryptPasswordEncoder().encode(&amp;quot;123456&amp;quot;)).roles(&amp;quot;ADMIN&amp;quot;);
    auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()).withUser(&amp;quot;dba&amp;quot;).password(new BCryptPasswordEncoder().encode(&amp;quot;123456&amp;quot;)).roles(&amp;quot;DBA&amp;quot;);

    //Spring Security 5.0之前的写法，5.0之后，如果没有指定密码编码器，将会报There is no PasswordEncoder mapped for the id &amp;quot;null&amp;quot;的错
    /*auth.inMemoryAuthentication().withUser(&amp;quot;admin&amp;quot;).password(&amp;quot;123456&amp;quot;).roles(&amp;quot;ADMIN&amp;quot;);
    auth.inMemoryAuthentication().withUser(&amp;quot;dba&amp;quot;).password(&amp;quot;123456&amp;quot;).roles(&amp;quot;DBA&amp;quot;);*/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;配置拦截路径&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void configure(HttpSecurity http) throws Exception {
http.authorizeRequests()
        //配置拦截路径以及认证通过的身份，此处拦截任意/admin/**路径，必须以ADMIN身份登录
        .antMatchers(&amp;quot;/admin/**&amp;quot;).access(&amp;quot;hasRole(&#39;ROLE_ADMIN&#39;)&amp;quot;)
        //配置拦截路径以及认证通过的身份，此处指定只有访问/dba/**的GET请求会被拦截认证，可使用DBA和ADMIN身份访问
        .antMatchers(HttpMethod.GET,&amp;quot;/dba/**&amp;quot;).access(&amp;quot;hasAnyRole(&#39;ROLE_DBA&#39;,&#39;ROLE_ADMIN&#39;)&amp;quot;)
        //表明除了上述路径需要拦截认证外，其余路径全部不进行认证
        .anyRequest().permitAll()
        //add()方法用于连接各种配置指令
       .and() 
       //当重写configure(HttpSecurity http)方法后，将失去Spring Security的默认登录页，可以使用formLogin()重新启用
       .formLogin();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中各关键方法源码如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;antMatchers（）&amp;mdash;指定拦截规则&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//拦截目标路径数组
public C antMatchers(String... antPatterns) {
   return chainRequestMatchers(RequestMatchers.antMatchers(antPatterns));
}

//拦截指定访问方式的目标路径
public C antMatchers(HttpMethod method, String... antPatterns) {
   return chainRequestMatchers(RequestMatchers.antMatchers(method, antPatterns));
}

//拦截应用内所有目标访问方式的请求
public C antMatchers(HttpMethod method) {
   return antMatchers(method, new String[] { &amp;quot;/**&amp;quot; });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;access（）&amp;mdash;-指定拦截通过的条件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//允许该拦截通过的条件
public ExpressionInterceptUrlRegistry access(String attribute) {
   if (not) {
      attribute = &amp;quot;!&amp;quot; + attribute;
   }
   interceptUrl(requestMatchers, SecurityConfig.createList(attribute));
   return ExpressionUrlAuthorizationConfigurer.this.REGISTRY;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;hasRole()&amp;mdash;&amp;ndash;是否具有某个角色身份&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//等同于hasRole
public final boolean hasAuthority(String authority) {
   return hasAnyAuthority(authority);
}
//等同于hasAnyRole
public final boolean hasAnyAuthority(String... authorities) {
   return hasAnyAuthorityName(null, authorities);
}

//当前用户是否拥有指定角色
public final boolean hasRole(String role) {
   return hasAnyRole(role);
}

//多个角色是一个以逗号进行分隔的字符串。如果当前用户拥有指定角色中的任意一个则返回true
public final boolean hasAnyRole(String... roles) {
   return hasAnyAuthorityName(defaultRolePrefix, roles);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自定义登陆页&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们看到&lt;strong&gt;FormLoginConfigurer&lt;/strong&gt;()的源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public FormLoginConfigurer&amp;lt;HttpSecurity&amp;gt; formLogin() throws Exception {
   return getOrApply(new FormLoginConfigurer&amp;lt;&amp;gt;());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不想做过多配置，自定义的登陆页面应该：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;form的action应该提交到&amp;rdquo;/login&amp;rdquo;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;包含username的输入域且name属性为username&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;包含password的输入域且name属性为password&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;loginPage.jsp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;登陆页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;../login&amp;quot;&amp;gt;
        &amp;lt;label&amp;gt;登陆名：&amp;lt;/label&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;username&amp;quot;&amp;gt;
        &amp;lt;label&amp;gt;密码：&amp;lt;/label&amp;gt;&amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;password&amp;quot;&amp;gt;
        &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;提交&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述配置改为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Override
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
            //配置拦截路径以及认证通过的身份，此处拦截任意/admin/**路径，必须以ADMIN身份登录
            .antMatchers(&amp;quot;/admin/**&amp;quot;).access(&amp;quot;hasRole(&#39;ROLE_ADMIN&#39;)&amp;quot;)
            //配置拦截路径以及认证通过的身份，此处指定只有访问/dba/**的GET请求会被拦截认证，可使用DBA和ADMIN身份访问
            .antMatchers(HttpMethod.GET,&amp;quot;/dba/**&amp;quot;).access(&amp;quot;hasAnyRole(&#39;ROLE_DBA&#39;,&#39;ROLE_ADMIN&#39;)&amp;quot;)
            //表明除了上述路径需要拦截认证外，其余路径全部不进行认证
            .anyRequest().permitAll()
            //add()方法用于连接各种配置指令
           .and() 
           //当重写configure(HttpSecurity http)方法后，将失去Spring Security的默认登录页，可以使用formLogin()重新启用
           .formLogin()
           //将登录页指向视图名为loginPage的视图
           .loginPage(&amp;quot;/loginPage&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建LoginController作为视图指向&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class LoginController {

    @RequestMapping(&amp;quot;/loginPage&amp;quot;)
    public String login(){
        return &amp;quot;loginPage&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_09_11.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第七章:SpringMVC的高级技术</title>
      <link>https://keep-zero.github.io/2019/spring_action07/</link>
      <pubDate>Sat, 31 Aug 2019 23:21:13 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action07/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;一-springmvc配置的替代方案&#34;&gt;一、SpringMVC配置的替代方案&lt;/h2&gt;

&lt;h3 id=&#34;ⅰ-注册filter&#34;&gt;Ⅰ、注册Filter&lt;/h3&gt;

&lt;p&gt;SpingMVC的&lt;strong&gt;AbstractAnnotationConfigDispatcherServletInitializer&lt;/strong&gt;提供了十分方便的注册过滤器的方法，通过重载&lt;strong&gt;getServletFilters()&lt;/strong&gt;方法将我们自定义的过滤器注册到上下文中&lt;/p&gt;

&lt;p&gt;如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    /*AbstractAnnotationConfigDispatcherServletInitializer 会同时创
    建 DispatcherServlet 和 ContextLoaderListener 。 GetServlet-ConfigClasses() 方法返回的带有 @Configuration 注解的
    类将会用来定义 DispatcherServlet 应用上下文中的 bean 。 getRootConfigClasses() 方法返回的带有 @Configuration 注解的类将
    会用来配置 ContextLoaderListener 创建的应用上下文中的 bean 。*/

    @Override
    protected Class&amp;lt;?&amp;gt;[] getRootConfigClasses() {
        return new Class[]{RootConfig.class};
    }

    @Override
    protected Class&amp;lt;?&amp;gt;[] getServletConfigClasses() {
        return new Class[]{WebConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        logger.debug(&amp;quot;DispatcherServlet获取匹配的前端控制器。。。。。。&amp;quot;);
        return new String[]{&amp;quot;/&amp;quot;};
    }

    /**
     * 注册过滤器
     */
    @Override
    protected Filter[] getServletFilters() {
        //将自定义过滤器实例数组返回
        return new Filter[]{new MyFilter()};
    }
}

/**
 * 过滤器类
 */
public class MyFilter implements Filter {

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        logger.debug(&amp;quot;过滤器初始化&amp;quot;);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        logger.debug(&amp;quot;执行过滤器&amp;quot;);

        Map&amp;lt;String, String[]&amp;gt; parameterMap = servletRequest.getParameterMap();

        Set&amp;lt;String&amp;gt; keySet = parameterMap.keySet();

        for(String key : keySet){
            logger.debug(&amp;quot;参数名：{},参数值：{}&amp;quot;,key,parameterMap.get(key));
        }

        /**
         * 执行该方法，如果有下一个过滤器则执行下一个过滤器，如果没有，则执行目标方法
         * 如果不执行该方法，将无法访问目标路径请求
         */
        filterChain.doFilter(servletRequest,servletResponse);
    }

    @Override
    public void destroy() {

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;页面访问结果
&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_07_01.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;2019-03-07 17:19:53.859 DEBUG com.my.spring.filter.MyFilter - 执行过滤器
2019-03-07 17:19:53.860 DEBUG com.my.spring.filter.MyFilter - 参数名：data,参数值：[{&#39;id&#39;:0}]
2019-03-07 17:19:53.863 DEBUG org.springframework.web.servlet.DispatcherServlet - GET &amp;quot;/SpringAction07/getBean?data={%27id%27:0}&amp;quot;, parameters={masked}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ⅱ-xml配置springmvc&#34;&gt;Ⅱ、XML配置SpringMVC&lt;/h3&gt;

&lt;p&gt;如果是在Servlet3.0以下环境（tomcat7.0以下），使用纯注解实现SpringMVC就不可能实现了，这时候我们需要借助web.xml文件进行配置，但是我们并不希望全部使用xml进行配置，所以我们可以简单配置初始化的内容，其他配置仍使用javaConfig配置方式。&lt;/p&gt;

&lt;p&gt;将SpittrWebAppInitializer初始化类去除，使用web.xml代替：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!DOCTYPE web-app PUBLIC
 &amp;quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&amp;quot;
 &amp;quot;http://java.sun.com/dtd/web-app_2_3.dtd&amp;quot; &amp;gt;

&amp;lt;web-app&amp;gt;
  &amp;lt;display-name&amp;gt;Archetype Created Web Application&amp;lt;/display-name&amp;gt;

  &amp;lt;!--配置使用java配置--&amp;gt;
  &amp;lt;context-param&amp;gt;
   &amp;lt;param-name&amp;gt;contextClass&amp;lt;/param-name&amp;gt;
   &amp;lt;param-value&amp;gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&amp;lt;/param-value&amp;gt;
  &amp;lt;/context-param&amp;gt;

  &amp;lt;!--指定根配置类:RootConfig--&amp;gt;
  &amp;lt;context-param&amp;gt;
    &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;com.my.spring.config.RootConfig&amp;lt;/param-value&amp;gt;
  &amp;lt;/context-param&amp;gt;

  &amp;lt;!--注册ContextLoaderListener--&amp;gt;
  &amp;lt;listener&amp;gt;
    &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt;
  &amp;lt;/listener&amp;gt;

  &amp;lt;!--注册DispatcherServlet--&amp;gt;
  &amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;!--使用java配置--&amp;gt;
    &amp;lt;init-param&amp;gt;
      &amp;lt;param-name&amp;gt;contextClass&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;

    &amp;lt;!--指定DispatcherServlet配置类:WebConfig--&amp;gt;
    &amp;lt;init-param&amp;gt;
      &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;com.my.spring.config.WebConfig&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
  &amp;lt;/servlet&amp;gt;

  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动应用，访问正常！&lt;/p&gt;

&lt;h2 id=&#34;二-处理文件上传multipart&#34;&gt;二、处理文件上传multipart&lt;/h2&gt;

&lt;p&gt;前面所遇到的表单处理，我们处理的都是简单的字符串形式提交，但是上传文件进行提交是一个应用十分常见的需求，文件上传提交的格式是multipart格式，自然不可以像处理字符串形式参数一样去处理。SpringMVC提供了MultipartFile接口用来处理上传的文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface MultipartFile extends InputStreamSource {
    String getName();

    @Nullable
    String getOriginalFilename();

    @Nullable
    String getContentType();

    boolean isEmpty();

    long getSize();

    byte[] getBytes() throws IOException;

    InputStream getInputStream() throws IOException;

    default Resource getResource() {
        return new MultipartFileResource(this);
    }

    void transferTo(File var1) throws IOException, IllegalStateException;

    default void transferTo(Path dest) throws IOException, IllegalStateException {
        FileCopyUtils.copy(this.getInputStream(), Files.newOutputStream(dest));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，MultipartFile接口可以用来获取文件名，文件大小等信息，还提供了一个InputStream,用来将文件以流的方式读取，还提供了一个便利的 transferTo() 方法，它能够帮助我们将上传的文件写入到文件系统中。&lt;/p&gt;

&lt;p&gt;使用MultiparFile实现文件上传之前需要先配置Multipart解析器MultipartResolver，Spring3.1后内置两个MultipartResolver的实现供我们选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CommonsMultipartResolver&lt;/strong&gt;: 使用&lt;strong&gt;Jakarta Commons FileUpload&lt;/strong&gt;解析multipart请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;StandardServletMultipartResolver&lt;/strong&gt;: 依赖于&lt;strong&gt;Servlet3.0&lt;/strong&gt;对multipart请求的支持。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一般来说，&lt;strong&gt;StandardServletMultipartResolver&lt;/strong&gt;会是更好的方案，因为它并不需要依赖于其他项目，使用原生的Servlet支持。只不过它只支持Servlet3.0以上的版本，如果低于等于Servlet3.0环境，需要使用CommonsMultipartResolver实现&lt;/p&gt;

&lt;h3 id=&#34;ⅰ-使用standardservletmultipartresolver实现文件上传&#34;&gt;Ⅰ、使用StandardServletMultipartResolver实现文件上传&lt;/h3&gt;

&lt;p&gt;①配置解析器，在上文代码的WebConfig中配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class WebConfig extends WebMvcConfigurationSupport {

    /**
     * 定义一个视图解析器
     *
     **/
    @Bean
    public ViewResolver viewResolver(){
        InternalResourceViewResolver resourceViewResolver = new InternalResourceViewResolver();
        resourceViewResolver.setPrefix(&amp;quot;/WEB-INF/view/&amp;quot;);
        resourceViewResolver.setSuffix(&amp;quot;.jsp&amp;quot;);
        resourceViewResolver.setExposeContextBeansAsAttributes(true);
        resourceViewResolver.setViewClass(org.springframework.web.servlet.view.JstlView.class);
        return resourceViewResolver;
    }

    /**
     * 配置Multipart解析器
     *
     */
    @Bean
    public MultipartResolver multipartResolver(){
        return new StandardServletMultipartResolver();
    }

    @Override
    protected void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②在&lt;strong&gt;SpittrWebAppInitializer&lt;/strong&gt;中配置文件上传的初始化参数（必须）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//通过重载customizeRegistration()方法来配置multipart的默认参数
@Override
protected void customizeRegistration(ServletRegistration.Dynamic registration) {
    registration.setMultipartConfig(               
            new MultipartConfigElement(&amp;quot;C:\\Users\\xxx\\Desktop\\uploads&amp;quot;,2097152,4194304,20000000));
    //设置写入的临时路径（可绝对路径）
    //上传文件的最大容量（字节为单位），默认无限制。
    //整个multipart请求的最大容量（字节为单位），默认无限制。
    //在上传的过程中，如果文件大小达到了一个指定的最大容量，将会写入到临时文件路劲中。默认为0，也就是上传的文件都会写入到磁盘上。
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③编写文件上传controller方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(value = &amp;quot;/upload&amp;quot;,method = RequestMethod.POST)
public String upload(@RequestPart(&amp;quot;file&amp;quot;) MultipartFile multipartFile, Model model) throws IOException {

    String fileName = new String(multipartFile.getOriginalFilename().getBytes(&amp;quot;utf-8&amp;quot;));
    //使用multipartFile的transferTo方法将文件存放到桌面
    multipartFile.transferTo(new File(&amp;quot;C:\\Users\\xxx\\Desktop\\&amp;quot;+multipartFile.getOriginalFilename()));

    model.addAttribute(&amp;quot;fileName&amp;quot;,fileName);
    model.addAttribute(&amp;quot;fileSize&amp;quot;,multipartFile.getSize());

    return &amp;quot;showFile&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;④编写上传文件的JSP&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h2&amp;gt;Hello World!&amp;lt;/h2&amp;gt;
    &amp;lt;!--此处必须设置form的enctype属性设置为multipart/form-data，否则会报CrrentRquest not a MultipartFile Request--&amp;gt;
    &amp;lt;form action=&amp;quot;./upload&amp;quot; method=&amp;quot;post&amp;quot; enctype=&amp;quot;multipart/form-data&amp;quot;&amp;gt;
        &amp;lt;label&amp;gt;文件;&amp;lt;/label&amp;gt;&amp;lt;input type=&amp;quot;file&amp;quot; name=&amp;quot;file&amp;quot;&amp;gt;
        &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;提交&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑤编写文件信息视图：showFile.jsp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
&amp;lt;%@ page isELIgnored=&amp;quot;false&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;文件展示&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
文件名称：
&amp;lt;c:out value=&amp;quot;${fileName}&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt;&amp;lt;br&amp;gt;
文件大小：
&amp;lt;c:out value=&amp;quot;${fileSize}&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt;KB
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;页面效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_07_02.jpg&#34; alt=&#34;&#34; /&gt;
点击提交，将文件提交至服务器，上传成功
&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_07_03.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ⅱ-使用commonsmultipartresolver实现文件上传&#34;&gt;Ⅱ、使用CommonsMultipartResolver实现文件上传&lt;/h3&gt;

&lt;p&gt;Spring内置了 &lt;strong&gt;CommonsMultipartResolver&lt;/strong&gt; ，可以作为 StandardServletMultipartResolver 的替代方案，但是，由于使用的是Commons FileUpload的上传方式，需要引入jar支持：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-io&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-fileupload&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-fileupload&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最简单的配置方式就是其构造函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public MultipartResolver multipartResolver() throws IOException
{
    return new CommonsMultipartResolver();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置文件上传参数，与 StandardServletMultipartResolver 有所不同，CommonsMultipart-Resolver 不会强制要求设置临时文件路径。默认情况下，这个路径就是 Servlet 容器的临时目录。不过，通过设置 uploadTempDir 属性，我们可以将其指定为一个不同的位置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public MultipartResolver multipartResolver() throws IOException
{
    CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver();
   //设置临时文件夹
    multipartResolver.setUploadTempDir(new FileSystemResource(&amp;quot;C:\\Users\\xxx\\Desktop\\uploads&amp;quot;));
    //设置最大内存大小
    multipartResolver.setMaxInMemorySize(100000);
    //设置上传文件的最大容量
    multipartResolver.setMaxUploadSize(2097152);
    return multipartResolver;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经测试，上传成功&lt;/p&gt;

&lt;p&gt;注：如果没有引入上述两个jar包，会报文件找不到的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;javax.servlet.ServletException: Servlet.init() for servlet dispatcher threw exception

Factory method &#39;multipartResolver&#39; threw exception; nested exception is java.lang.NoClassDefFoundError: org/apache/commons/fileupload/FileItemFactory
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ⅲ-文件下载实现&#34;&gt;Ⅲ、文件下载实现&lt;/h3&gt;

&lt;p&gt;文件下载使用Spring提供的ResponseEntity实现&lt;/p&gt;

&lt;p&gt;ResponseEntity：可以添加HttpStatus状态码的HttpEntity的扩展类。被用于RestTemplate和Controller层方法&lt;/p&gt;

&lt;p&gt;①编写下载文件的controller方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(&amp;quot;/download&amp;quot;)
public ResponseEntity&amp;lt;byte[]&amp;gt; filedownload(HttpServletRequest request, String filename) throws Exception{
     //此处指定只从桌面获取文件
     String path = &amp;quot;C:\\Users\\xxx\\Desktop\\&amp;quot;;
     File file = new File(path+File.separator+filename);

     //返回头部设置
     HttpHeaders headers = new HttpHeaders();
     headers.setContentDispositionFormData(&amp;quot;attachment&amp;quot;,filename);
    headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);

    //获取文件输入流
    InputStream is = new FileInputStream(file);

    //将文件转换成byte数组
    byte[] bytes = new byte[is.available()];
    is.read(bytes);

    //封装信息返回
    return new ResponseEntity&amp;lt;byte[]&amp;gt;(bytes,headers, HttpStatus.OK);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②编写JSP文件下载资源：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
&amp;lt;%@ page isELIgnored=&amp;quot;false&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;文件展示&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
文件名称：
&amp;lt;c:out value=&amp;quot;${fileName}&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt;&amp;lt;br&amp;gt;
文件大小：
&amp;lt;c:out value=&amp;quot;${fileSize}&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt;KB
&amp;lt;a href=&amp;quot;${pageContext.request.contextPath}/download?filename=${fileName}&amp;quot;&amp;gt;文件下载&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;页面展示如下，点击文件下载，弹出资源管理窗口，将其保存至目标路径
&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_07_04.jpg&#34; alt=&#34;&#34; /&gt;
下载完成&lt;/p&gt;

&lt;h2 id=&#34;三-处理异常&#34;&gt;三、处理异常&lt;/h2&gt;

&lt;p&gt;自定义异常在SpringMVC中是十分普遍的，有时候我们需要控制异常的输出样式，而不是赤裸裸的将错误信息展示在用户面前，那样并不友好，可能还有点辣眼睛&lt;/p&gt;

&lt;p&gt;那么，SpringMVC中，怎么捕获异常并友好输出呢？也许你会想到使用try-catch的方式去处理，但是那样耦合性太强了，SpringMVC提供了两个注解进行捕捉处理&lt;/p&gt;

&lt;h3 id=&#34;ⅰ-exceptionhandler-myexception-class-捕捉异常&#34;&gt;Ⅰ、@ExceptionHandler(MyException.class)捕捉异常&lt;/h3&gt;

&lt;p&gt;@ExceptionHandler(）注解&lt;strong&gt;可以捕捉当前控制器内所有方法抛出的特定异常，而不需要在控制器内每个方法上去标识&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;①编写自定义异常类，继承Exception&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyException extends Exception{
    public MyException() {
        super();
    }

    public MyException(String message) {
        super(message);
    }

    public MyException(String message, Throwable cause) {
        super(message, cause);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②编写测试Controller&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class ExceptionController {

    @ExceptionHandler(MyException.class)//捕捉当前控制器内任意方法抛出MyException
    public String toError(MyException myException, Model model){
        model.addAttribute(&amp;quot;error&amp;quot;,myException.getMessage());
        //返回指定的错误视图，经过特殊编写，会比浏览器默认错误页面更美观
        return &amp;quot;error&amp;quot;;
    }

    @RequestMapping(&amp;quot;/exception&amp;quot;)
    public String testException() throws MyException {
        //为了测试抛出异常，设置条件恒为true
        if(1==1){
            throw new MyException(&amp;quot;系统搞错咯&amp;quot;);
        }

        return &amp;quot;123&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③编写错误页面：error.jsp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
&amp;lt;%@ page isELIgnored=&amp;quot;false&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;错误页面&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;您好，系统异常，请稍后重试&amp;lt;/h1&amp;gt;
    &amp;lt;hr&amp;gt;
    &amp;lt;!--使用JSTL标签和EL表达式从modle获取错误信息--&amp;gt;
    &amp;lt;c:out value=&amp;quot;${error}&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_07_05.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ⅱ-controlleradvice-为所有控制器处理异常&#34;&gt;Ⅱ、@ControllerAdvice，为所有控制器处理异常&lt;/h3&gt;

&lt;p&gt;即便如上述代码已经十分方便，我们仍有可能需要在每个有可能抛出异常的控制器内编写@ExceptionHandler(）注解方法，显然Spring可以做的更好。&lt;/p&gt;

&lt;p&gt;@ControllerAdvice注解标注的类可以捕捉应用内所有的错误，并结合@ExceptionHandler(）在其内进行特殊处理，系统内抛出的所有错误，都会经过该类处理&lt;/p&gt;

&lt;p&gt;①编写统一处理类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@ControllerAdvice
public class ExceptionHelper {
    //对特殊异常进行处理
    @ExceptionHandler(MyException.class)
    public String toError(MyException myException, Model model){
        model.addAttribute(&amp;quot;error&amp;quot;,myException.getMessage());
        return &amp;quot;error&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②普通controller方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class ExceptionController {

    @RequestMapping(&amp;quot;/exception&amp;quot;)
    public String testException() throws MyException {
        //为了测试抛出异常，设置条件恒为true
        if(1==1){
            throw new MyException(&amp;quot;系统搞错咯&amp;quot;);
        }

        return &amp;quot;123&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果：显然我们并没有在ExceptionController中对该错误进行显式处理，结果却跳转到错误页面，证明处理成功&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_07_06.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第六章:渲染视图（表达式，标签库，模板）</title>
      <link>https://keep-zero.github.io/2019/spring_action06/</link>
      <pubDate>Sat, 31 Aug 2019 23:21:07 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action06/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;前言：视图解析器可以将逻辑视图名转换成物理实现&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;一-视图解析器&#34;&gt;一、视图解析器&lt;/h2&gt;

&lt;p&gt;Spring提供了&lt;strong&gt;13个基本的视图解析器&lt;/strong&gt;，能够&lt;strong&gt;将逻辑视图名转换为物理实现&lt;/strong&gt;，如上一篇中提到的InternalResourceViewResolver。&lt;/p&gt;

&lt;p&gt;此处我们只了解其中几个比较常用的视图解析器：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FreeMarkerViewResolver&lt;/strong&gt;：将视图解析为 &lt;strong&gt;FreeMarker&lt;/strong&gt; 模板&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;InternalResourceViewResolver&lt;/strong&gt;：将视图解析为Web应用的内部资源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TilesViewResolver&lt;/strong&gt;：将视图解析为 &lt;strong&gt;Apache Tile&lt;/strong&gt; 定义，其中 tile ID 与视图名称相同。注意有两个不同的TilesViewResolver实现，分别对应于 Tiles 2.0 和Tiles 3.0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ThymeleafViewResolver&lt;/strong&gt;： 将逻辑视图名称解析为 &lt;strong&gt;Thymeleaf&lt;/strong&gt; 模板视图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用不同的解析器可以实现将视图解析成不同类型的内容展现&lt;/p&gt;

&lt;h2 id=&#34;二-具体视图解析器分析demo&#34;&gt;二、具体视图解析器分析Demo&lt;/h2&gt;

&lt;h3 id=&#34;ⅰ-创建jsp视图&#34;&gt;Ⅰ、创建JSP视图&lt;/h3&gt;

&lt;p&gt;基础实现如上一章&lt;a href=&#34;https://www.jianshu.com/p/b74ff4de15e8&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;《Spring实战》-第五章:Web中的Spring（SpringMVC注解实现）&lt;/a&gt;
)所述，&lt;strong&gt;InternalResourceViewResolver&lt;/strong&gt;还支持将逻辑视图名转换成&lt;strong&gt;JstlView&lt;/strong&gt;，我们只需要修改其&lt;strong&gt;viewClass为org.springframework.web.servlet.view.JstlView.class&lt;/strong&gt;即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Bean
public ViewResolver viewResolver(){
    InternalResourceViewResolver resourceViewResolver = new InternalResourceViewResolver();
    resourceViewResolver.setPrefix(&amp;quot;/WEB-INF/view/&amp;quot;);
    resourceViewResolver.setSuffix(&amp;quot;.jsp&amp;quot;);
    resourceViewResolver.setExposeContextBeansAsAttributes(true);
    resourceViewResolver.setViewClass(org.springframework.web.servlet.view.JstlView.class);
    return resourceViewResolver;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ⅱ-使用apache-tile视图定义布局&#34;&gt;Ⅱ、使用Apache Tile视图定义布局&lt;/h3&gt;

&lt;p&gt;如果一个应用多个视图需要使用很多重复性的内容，如头部，尾部等，或许我们会一个个的去复制使用，但是一旦做了任何更改，将需要同步进行多次更改，效率是很低的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apache Tiles是一个JavaEE应用的页面布局框架。Tiles框架提供了一种模板机制，可以为某一类页面定义一个通用的模板，该模板定义了页面的整体布局。布局由可以复用的多个块组成，每个页面可以有选择性的重新定义块而达到组件的复用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SpringMVC结合Tile使用，案例如下：&lt;/p&gt;

&lt;p&gt;引入tiles支持jar包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--tiles--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.tiles&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;tiles-jsp&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;①创建&lt;strong&gt;TilesConfig&lt;/strong&gt;配置类，同时定义视图解析器&lt;strong&gt;TilesViewResolver&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableAspectJAutoProxy
@ComponentScan(basePackages = {&amp;quot;com.my.spring.controller&amp;quot;})
@EnableWebMvc /*&amp;lt;mvc:annotation-driven&amp;gt; 开启mvc配置*/
public class TilesConfig {
    /**
     * 定义默认处理器
     */
    @Bean
    public TilesConfigurer tilesConfigurer(){
        TilesConfigurer tilesConfigurer = new TilesConfigurer();
        //指定tiles的位置
        tilesConfigurer.setDefinitions(new String[]{&amp;quot;/WEB-INF/layout/tiles.xml&amp;quot;});
        //开启刷新功能
        tilesConfigurer.setCheckRefresh(true);

        return tilesConfigurer;
    }

    //定义使用TilesViewResolver
    @Bean
    public ViewResolver viewResolver(){
        return new TilesViewResolver();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②定义Tiles&lt;/p&gt;

&lt;p&gt;由上述配置代码中可以，Tiles文件是一个xml文件，创建位于&lt;strong&gt;/WEB-INF/layout/tiles.xml&lt;/strong&gt;，使用&lt;strong&gt;&lt;tiles-definitions&gt;&lt;/strong&gt;作为根节点,使用&lt;strong&gt;&lt;definition&gt;&lt;/strong&gt;节点包裹一个Tile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;
&amp;lt;!DOCTYPE tiles-definitions PUBLIC
        &amp;quot;-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN&amp;quot;
        &amp;quot;http://tiles.apache.org/dtds/tiles-config_3_0.dtd&amp;quot;&amp;gt;
&amp;lt;tiles-definitions&amp;gt;
    &amp;lt;!--定义一个名为base的tile，其模板文件时WEB-INF/layout下的base.jsp--&amp;gt;
    &amp;lt;definition name=&amp;quot;base&amp;quot; template=&amp;quot;/WEB-INF/layout/base.jsp&amp;quot;&amp;gt;
        &amp;lt;!--定义属性header，指向视图/WEB-INF/layout/header.jsp--&amp;gt;
        &amp;lt;put-attribute name=&amp;quot;header&amp;quot; value=&amp;quot;/WEB-INF/layout/header.jsp&amp;quot;/&amp;gt;
        &amp;lt;!--定义属性footer，指向视图/WEB-INF/layout/header.jsp--&amp;gt;
        &amp;lt;put-attribute name=&amp;quot;footer&amp;quot; value=&amp;quot;/WEB-INF/layout/footer.jsp&amp;quot;/&amp;gt;
    &amp;lt;/definition&amp;gt;
    &amp;lt;!--定义一个名为home的tile，继承了名为base的tile，自动继承header和footer属性--&amp;gt;
    &amp;lt;definition name=&amp;quot;home&amp;quot; extends=&amp;quot;base&amp;quot; &amp;gt;
        &amp;lt;!--定义属性body，指向视图/WEB-INF/layout/home.jsp--&amp;gt;
        &amp;lt;put-attribute name=&amp;quot;body&amp;quot; value=&amp;quot;/WEB-INF/view/home.jsp&amp;quot;/&amp;gt;
    &amp;lt;/definition&amp;gt;
&amp;lt;/tiles-definitions&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③编写主模板base.jsp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;!--引入tiles标签库--&amp;gt;
&amp;lt;%@ taglib uri=&amp;quot;http://tiles.apache.org/tags-tiles&amp;quot; prefix=&amp;quot;t&amp;quot;%&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;base&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id = &amp;quot;header&amp;quot;&amp;gt;
        &amp;lt;!--此处引入上tiles.xml文件中定义的属性header，实际上就是将header属性指向的header.jsp引入此处--&amp;gt;
        &amp;lt;t:insertAttribute name=&amp;quot;header&amp;quot;&amp;gt;&amp;lt;/t:insertAttribute&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;
         &amp;lt;!--此处引入属性body，一般来说这个地方都是用来作为空占位，所以base tile才没有body属性，此处是被继承者填充的--&amp;gt;
        &amp;lt;t:insertAttribute name=&amp;quot;body&amp;quot;&amp;gt;&amp;lt;/t:insertAttribute&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;footer&amp;quot;&amp;gt;
        &amp;lt;!--此处引入上tiles.xml文件中定义的属性footer，实际上就是将footer属性指向的footer.jsp引入此处--&amp;gt;
        &amp;lt;t:insertAttribute name=&amp;quot;footer&amp;quot;&amp;gt;&amp;lt;/t:insertAttribute&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;④编写属性模板文件：header.jsp和footer.jsp这两个文件作为模板文件都是十分简洁的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;header.jsp:

    &amp;lt;div style=&amp;quot;font-size: medium;font-weight: bolder&amp;quot;&amp;gt;TestDemo&amp;lt;/div&amp;gt;

footer.jsp:
    &amp;lt;span style=&amp;quot;align-content: center&amp;quot;&amp;gt;@create by Mr D&amp;lt;/span&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑤编写目标文件：home.jsp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;%@ taglib uri=&amp;quot;http://tiles.apache.org/tags-tiles&amp;quot; prefix=&amp;quot;t&amp;quot;%&amp;gt;
&amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑥编写基本Controller方法home()，方法返回一个逻辑视图名“&lt;strong&gt;home&lt;/strong&gt;”，经过&lt;strong&gt;TilesViewResolver&lt;/strong&gt;后被解析为完整视图：base.jsp中的&lt;strong&gt;body属性由home.jsp填充&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class HomeController {

    @RequestMapping(method = RequestMethod.GET,value = &amp;quot;/home&amp;quot;)
    public String home(){
        //返回试图名为home的视图
        return &amp;quot;home&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑦浏览器访问结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_06_01.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ⅲ-使用thymeleaf&#34;&gt;Ⅲ、使用Thymeleaf&lt;/h3&gt;

&lt;p&gt;尽管JSP和Tiles十分便捷，但是终究建立在Servlet的基础之上，有时候很多代码并不是完全的前端代码，使其变得很混乱。&lt;strong&gt;Thymeleaf&lt;/strong&gt;模板是&lt;strong&gt;原生的，不依赖于标签库&lt;/strong&gt;。它能&lt;strong&gt;在接受原始 HTML 的地方进行编辑和渲染&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;案例如下：&lt;/p&gt;

&lt;p&gt;引入Thymeleaf支持jar包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.thymeleaf/thymeleaf-spring4 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.thymeleaf&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;thymeleaf-spring4&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.9.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;①创建&lt;strong&gt;ThymeleafConfig&lt;/strong&gt;配置类，装配&lt;strong&gt;ThymeleafViewResolver&lt;/strong&gt;用于将逻辑视图名称解析为 Thymeleaf 模板视图,&lt;strong&gt;SpringTemplateEngine&lt;/strong&gt;用于处理模板并渲染结果；&lt;strong&gt;TemplateResolver&lt;/strong&gt; 用于加载 &lt;strong&gt;Thymeleaf&lt;/strong&gt; 模板&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
public class ThymeleafConfig implements WebMvcConfigurer {
    @Autowired
    private ApplicationContext applicationContext;

    /**
     * 装配模板引擎（解析器），用于处理模板并渲染结果
     */
    @Bean
    public SpringResourceTemplateResolver templateResolver() {
        SpringResourceTemplateResolver templateResolver = new SpringResourceTemplateResolver();
        templateResolver.setCharacterEncoding(&amp;quot;UTF-8&amp;quot;);
        templateResolver.setApplicationContext(applicationContext);
        templateResolver.setPrefix(&amp;quot;/WEB-INF/view/&amp;quot;);//指定视图前缀
        templateResolver.setSuffix(&amp;quot;.html&amp;quot;);//指定视图后缀
        return templateResolver;
    }

    /**
     * 装配模板引擎，用于处理模板并渲染结果
     */
    @Bean
    public SpringTemplateEngine templateEngine() {
        SpringTemplateEngine templateEngine = new SpringTemplateEngine();
        templateEngine.setTemplateResolver(templateResolver());
        templateEngine.setEnableSpringELCompiler(true);

        return templateEngine;
    }

    /**
     * 装配视图解析器
     */
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        ThymeleafViewResolver resolver = new ThymeleafViewResolver();
        resolver.setCharacterEncoding(&amp;quot;UTF-8&amp;quot;);
        resolver.setTemplateEngine(templateEngine());
        registry.viewResolver(resolver);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②编写基本页面：&lt;strong&gt;ThymeleafHtml.html&lt;/strong&gt;,绑定bean对象，将bean对象属性作为输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;&amp;lt;!--引入thymeleaf支持--&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=utf-8&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;SpringMVC5+Thymeleaf示例&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Spring MVC + Thymeleaf Hello World example&amp;lt;/h1&amp;gt;
&amp;lt;p th:text=&amp;quot;${bean.id}&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p th:text=&amp;quot;${bean.name}&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③编写基础Controller方法，返回逻辑视图名指向ThymeleafHtml.html，并将数据封装返回&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(method = RequestMethod.GET,value = &amp;quot;/getBean&amp;quot;)
public String getBeanByParam(String data, Model model){

    JSONObject jo = JSON.parseObject(data);
    Integer id = jo.getInteger(&amp;quot;id&amp;quot;);
    BaseBean bean = this.baseService.findBean(id);

    model.addAttribute(&amp;quot;bean&amp;quot;,bean);

    return &amp;quot;ThymeleafHtml&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;④浏览器访问结果：可以看到，返回的bean成功被绑定到页面属性中&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_06_02.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但是，Thymeleaf更出色的地方是实现&lt;strong&gt;表单绑定&lt;/strong&gt;，将&lt;strong&gt;表单和对象绑定到一起&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;⑤创建一个AddBeanHtml.html文件，其中包含一个表单文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot; xmlns:th=&amp;quot;http://www.thymeleaf.org&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;addBean&amp;quot; th:object=&amp;quot;${baseBean}&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;error&amp;quot; th:if=&amp;quot;${#fields.hasErrors(&#39;*&#39;)}&amp;quot;&amp;gt;
            &amp;lt;ul&amp;gt;
                &amp;lt;li th:each=&amp;quot;err: ${#fields.errors(&#39;*&#39;)}&amp;quot; th:text=&amp;quot;${err}&amp;quot;&amp;gt;
                    Input is incorrect
                &amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;label th:class=&amp;quot;${#fields.hasErrors(&#39;id&#39;)}?&#39;error&#39;&amp;quot;&amp;gt;Id&amp;lt;/label&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; th:field=&amp;quot;*{id}&amp;quot; th:class=&amp;quot;${#fields.hasErrors(&#39;id&#39;)}?&#39;error&#39;&amp;quot;/&amp;gt;&amp;lt;br&amp;gt;
        &amp;lt;label th:class=&amp;quot;${#fields.hasErrors(&#39;name&#39;)}?&#39;error&#39;&amp;quot;&amp;gt;Name&amp;lt;/label&amp;gt;
        &amp;lt;input type=&amp;quot;text&amp;quot; th:field=&amp;quot;*{name}&amp;quot; th:class=&amp;quot;${#fields.hasErrors(&#39;name&#39;)}?&#39;error&#39;&amp;quot;/&amp;gt;&amp;lt;br&amp;gt;

        &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;提交&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑥编写基本控制方法，将上述代码提交的类展示到ThymeleafHtml.html中去&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(method = RequestMethod.POST,value = &amp;quot;/addBean&amp;quot;)
public String addBean(BaseBean baseBean, Model model){

    model.addAttribute(&amp;quot;bean&amp;quot;,baseBean);

    //返回试图名为home的视图
    return &amp;quot;ThymeleafHtml&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;网页请求如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_06_03.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_06_04.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第五章：Web中的Spring（SpringMVC注解实现）</title>
      <link>https://keep-zero.github.io/2019/spring_action05/</link>
      <pubDate>Sat, 31 Aug 2019 22:43:02 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action05/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前言：前面我们学习了关于Spring核心的IOC和AOP知识，除此之外，以此为基础，Spring的MVC框架还经常被用于Web开发（SpringMVC）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;一-什么是springmvc框架&#34;&gt;一、什么是SpringMVC框架？&lt;/h2&gt;

&lt;p&gt;在了解SpringMVC之前，我们先回顾一下Spring基础架构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_05_01.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Spring MVC 是Spring的一部分，基于模型 - 视图 - 控制器（ Model-View-Controller ， MVC ）模式实现，它能够帮你构建像 Spring 框架那样灵活和松耦合的 Web 应用程序。在实际开发中，接收浏览器的请求响应，对数据进行处理，然后返回页面进行显示。&lt;/p&gt;

&lt;h2 id=&#34;二-springmvc组成以及运行原理&#34;&gt;二、SpringMVC组成以及运行原理&lt;/h2&gt;

&lt;h3 id=&#34;ⅰ-springmvc的组成&#34;&gt;Ⅰ、SpringMVC的组成&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;DispatcherServlet&lt;/strong&gt;：前端控制器 （SpringMVC的核心）&amp;mdash;&amp;ndash;相当于MVC中的C，作为中心调用其他组件，降低其他组件之间的耦合性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HandlerMapping&lt;/strong&gt;：处理器映射器 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-根据用户请求找到对应路径的处理器（相当于处理器的名单）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HandlAdapter&lt;/strong&gt;：处理器适配器 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;调用执行处理器方法（适配器模式的应用）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Handler&lt;/strong&gt;：处理器 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;处理用户请求的类，相当于传统意义上的Servlet&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ViewResolver&lt;/strong&gt;：视图解析器 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;处理返回结果，将处理器适配器返回的数据模型转换成具体视图，并进行渲染输出（实际上就是将处理器返回的名称补充成具体的路径也就是一个视图，同时从数据模型中提取数据进行填充）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;View&lt;/strong&gt;：视图 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;视图是数据最终需要展现给客户的地方，Spring支持多种类型的视图：&lt;strong&gt;jstlVies,freemarkerView等，最常用的是JSP和使用模板实现的html等&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;ⅱ-springmvc请求响应流程&#34;&gt;Ⅱ、SpringMVC请求响应流程&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_05_02.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;①&lt;strong&gt;用户发起请求&lt;/strong&gt;，携带请求信息到前端控制器进行调度&lt;/p&gt;

&lt;p&gt;②&lt;strong&gt;前端控制器（DispatcherServlet）&lt;/strong&gt;调用&lt;strong&gt;处理器映射器&lt;/strong&gt;，根据请求信息从处理器映射器中找到访问路径的目标处理器&lt;/p&gt;

&lt;p&gt;③&lt;strong&gt;前端控制器（DispatcherServlet）&lt;/strong&gt;根据得到的目标&lt;strong&gt;处理器映射&lt;/strong&gt;，调用&lt;strong&gt;处理器适配器&lt;/strong&gt;方法（处理器适配器将处理器方法包装成适配器模式）&lt;/p&gt;

&lt;p&gt;④&lt;strong&gt;处理器适配器（HandlerAdapter）&lt;/strong&gt;调用&lt;strong&gt;处理器（Handler）&lt;/strong&gt;相应功能方法，并将结果返回给&lt;strong&gt;前端控制器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;⑤&lt;strong&gt;前端控制器（DispatcherServlet）&lt;/strong&gt;根据得到的数据结果和目标视图名称，调用&lt;strong&gt;视图解析器（ViewResolver）&lt;/strong&gt;返回目标视图完整路径&lt;/p&gt;

&lt;p&gt;⑥&lt;strong&gt;前端控制器（DispatcherServlet）&lt;/strong&gt;根据得到的&lt;strong&gt;视图&lt;/strong&gt;路径，对目标&lt;strong&gt;视图（view）&lt;/strong&gt;进行渲染（数据填充等），得到目标视图&lt;/p&gt;

&lt;p&gt;⑦&lt;strong&gt;前端控制器（DispatcherServlet）&lt;/strong&gt;将目标视图展现给用户&lt;/p&gt;

&lt;p&gt;从上述流程可以看到，SpringMVC的功能流转是围绕&lt;strong&gt;前端控制器（DispatcherServlet）&lt;/strong&gt;实现的，这样的好处是使得各个组件之间的耦合性大大降低，各个组件只做自己应该做的事情。其实这是大部分框架想要实现的目标。&lt;/p&gt;

&lt;p&gt;分析DispatcherServlet，从Spring官网查看到的结构图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_05_03.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从结构图可以看到，DispatcherServlet包含了两个Web应用上下文，用于独立控制，其中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Servlet WebApplicationContext&lt;/strong&gt;:管理用于网络请求的处理器适配器，视图解析器，处理器映射器和处理器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Root WebApplicationContext&lt;/strong&gt;：管理基本的数据库操作类，业务逻辑类等Bean&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过两个应用上下文管理基本Bean和网络Bean，互不干扰，但是其中管理的Bean之间可以互相使用&lt;/p&gt;

&lt;h2 id=&#34;三-springmvc的简单使用-注解方式&#34;&gt;三、SpringMVC的简单使用（注解方式）&lt;/h2&gt;

&lt;p&gt;首先我们应该先引入Spring对WebMvc的支持，maven引入如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!--引入网络Servlet支持--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--引入SpringMVC--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;①创建&lt;strong&gt;DispatcherServlet&lt;/strong&gt;类，继承并重载&lt;strong&gt;AbstractAnnotationConfigDispatcherServletInitializer&lt;/strong&gt;类的三个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//定义DispatcherServlet类名为WebAppInitializer
public class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    /**
     * 指定DispatcherServlet的基本Bean应用上下文配置类
     * @return
     */
    @Override
    protected Class&amp;lt;?&amp;gt;[] getRootConfigClasses() {
        return new Class[]{RootConfig.class};
    }

    /**
     * 指定DispatcherServlet的网络类应用上下文配置类
     * @return
     */
    @Override
    protected Class&amp;lt;?&amp;gt;[] getServletConfigClasses() {
        return new Class[]{WebConfig.class};
    }

    /**
     * 将DispatcherServlet映射到“/”，即应用内所有访问都会经过DispatcherServlet的处理
     * @return
     */
    @Override
    protected String[] getServletMappings() {
        logger.debug(&amp;quot;DispatcherServlet获取匹配的前端控制器。。。。。。&amp;quot;);
        return new String[]{&amp;quot;/&amp;quot;};
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②创建上述代码的两个配置类：&lt;strong&gt;RootConfig.java&lt;/strong&gt;和&lt;strong&gt;WebConfig.java&lt;/strong&gt;，其中，&lt;strong&gt;RootConfig只扫描除了WebConfig扫描范围外的基本类，而WebConfig只扫描基本的网络类，同时配置视图解析器和处理器映射器，并开启mvc配置&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//定义WebConfig配置类
@Configuration
@ComponentScan(basePackages = {&amp;quot;com.my.spring.controller&amp;quot;})//WebConfig扫描包的范围
@EnableWebMvc /*&amp;lt;mvc:annotation-driven&amp;gt; 开启mvc配置*/
public class WebConfig extends WebMvcConfigurationSupport {

    /**
     * 定义一个视图解析器
     *
     * @return org.springframework.web.servlet.ViewResolver
     *
     * @author xxx 2019/3/5
     * @version 1.0
     **/
    @Bean
    public ViewResolver viewResolver(){
        //基本的视图解析器
        InternalResourceViewResolver resourceViewResolver = new InternalResourceViewResolver();
        //视图前缀，指向WEB-INF目录下的view目录，意思是所有的视图名称进入视图解析器的时候都会被加上前缀
        resourceViewResolver.setPrefix(&amp;quot;/WEB-INF/view/&amp;quot;);
         //视图后缀，此处指定后缀为jsp,意思是所有的视图名称进入视图解析器的时候都会被加上后缀，前缀+view名+后缀得到完整路径
        resourceViewResolver.setSuffix(&amp;quot;.jsp&amp;quot;);
         //可以在JSP页面中通过${}访问beans
        resourceViewResolver.setExposeContextBeansAsAttributes(true);
        return resourceViewResolver;
    }

    /**
     * 配置一个默认的处理器,实现父类接口,自动处理静态资源的映射
     * @param configurer
     */
    @Override
    protected void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }
}

//定义RootConfig配置类
@Configuration
//指定扫描范围，排除过滤掉使用了@EnableWebMvc注解扫描范围的bean，不进行扫描
@ComponentScan(basePackages ={&amp;quot;com.my.spring&amp;quot;},excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION,value = {EnableWebMvc.class})})
public class RootConfig {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③编写基本的Bean类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Data//lombok的注解，编译添加setter和getter方法
public class BaseBean {

    private Integer id;

    private String name;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;④编写逻辑操作类（暂时没有用到数据库，所以只是模拟）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//定义基本Dao接口
public interface BaseRepository {
    /**
     * 根据id获取BaseBean
     * @param id 目标id
     * @return
     */
    BaseBean findOne(Integer id);
}

//定义基本Dao实现类，@Repository注解使用了@Component，可以被当作组件装配
@Repository
public class BaseRepositoryImpl implements BaseRepository {

    @Override
    public BaseBean findOne(Integer id) {
        if(id!=0){
            return null;
        }
        BaseBean baseBean = new BaseBean();
        baseBean.setId(0);
        baseBean.setName(&amp;quot;测试bean&amp;quot;);
        return baseBean;
    }
}

//定义基本Service接口
public interface BaseService {
     /**
     * 根据id获取BaseBean
     * @param id 目标id
     * @return
     */
    BaseBean findBean(Integer id);
}

//定义基本操作实现类,使用@Service注解，标明该类是一个service，该注解使用了@Comonnet注解，所以可被作为组件进行装配
@Service
public class BaseServiceImpl implements BaseService {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    //注入基本操作dao
    @Autowired
    private BaseRepository baseRepository;

    @Override
    public BaseBean findBean(Integer id) {
        return this.baseRepository.findOne(id);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑤创建处理类HomeController,使用@Controller注解标明当前类为一个处理类，同样使用@Component注解，可被装配&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class HomeController {

    @Autowired
    private BaseService baseService;

    /**
     *使用@RequestMapping注解，将当前方法作为可访问路径，value值指定了访问路径，而method值指定了访问方式
     */
    @RequestMapping(method = RequestMethod.GET,value = &amp;quot;/home&amp;quot;)
    public String home(){
        //返回试图名为home的视图
        return &amp;quot;home&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到上述代码，我们首先做最简单的测试，通过访问/home路径，访问具体的静态资源：&lt;/p&gt;

&lt;p&gt;根据WebConfig中的视图解析器，我们在相应路径下创建：&lt;strong&gt;/WEB-INF/view/home.jsp&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Home Page&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;路径如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_05_04.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;启动项目，页面访问如下：本项目名为SpringAction05&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_05_05.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从访问结果可以看到，访问被转向了home.jsp，而我们在controller方法中只是return了一个home，也就是说，视图解析器为我们补充了完整的路径并将视图返回给浏览器&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;注：&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;*&lt;strong&gt;AbstractAnnotationConfigDispatcherServletInitializer&lt;/strong&gt; 会同时创建 &lt;strong&gt;DispatcherServlet&lt;/strong&gt; 和 &lt;strong&gt;ContextLoaderListener&lt;/strong&gt; 。*&lt;/p&gt;

&lt;p&gt;*&lt;strong&gt;GetServlet-ConfigClasses()&lt;/strong&gt; 方法返回的带有 @Configuration 注解的类将会用来定义 DispatcherServlet 应用上下文中的 bean 。*&lt;/p&gt;

&lt;p&gt;*&lt;strong&gt;getRootConfigClasses()&lt;/strong&gt; 方法返回的带有 @Configuration 注解的类将会用来配置 ContextLoaderListener 创建的应用上下文中的 bean 。*&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;四-信息交互&#34;&gt;四、信息交互&lt;/h2&gt;

&lt;h3 id=&#34;ⅰ-传递模型数据到视图中&#34;&gt;Ⅰ、传递模型数据到视图中&lt;/h3&gt;

&lt;p&gt;有时候我们并不只是需要对访问进行转发，同时可能需要携带一些信息给浏览器端，SpringMVC提供了Model类对返回信息进行封装返回：&lt;/p&gt;

&lt;p&gt;下面我们在上述controller方法home()返回之前封装信息返回给视图，并从视图中获取到对应的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Controller
public class HomeController {

    @Autowired
    private BaseService baseService;

    @RequestMapping(method = RequestMethod.GET,value = &amp;quot;/home&amp;quot;)
    public String home(Model model){

        //往model中放置信息（key,value）
        model.addAttribute(&amp;quot;Message&amp;quot;,&amp;quot;I am HomePage!!!&amp;quot;);

        //返回试图名为home的视图
        return &amp;quot;home&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改home.jsp获取目标数据，此处我们使用JSTL标签库获取，所以需要先引入JSTL标签库的jar包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;!-- jstl --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;jstl&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;home.jsp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;&amp;lt;!--引入JSTL标签库，并以c为标签前缀--&amp;gt;
&amp;lt;%@ page isELIgnored=&amp;quot;false&amp;quot; %&amp;gt;&amp;lt;!--禁用tomcat自带的EL表达式，否则无法获取对应的数据--&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Home Page&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;
    &amp;lt;!--通过EL表达式获取key为Message的属性值--&amp;gt;
    &amp;lt;c:out value=&amp;quot;${Message}&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_05_06.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ⅱ-接受请求的输入&#34;&gt;Ⅱ、接受请求的输入&lt;/h3&gt;

&lt;p&gt;Spring MVC 允许以多种方式将客户端中的数据传送到控制器的处理器方法中，包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;查询参数（ Query Parameter ）。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径变量（ Path Variable ）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表单参数（ Form Parameter ）。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;①查询参数形式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们在controller中编写一个getBean方法，要求接收一个参数，&lt;strong&gt;参数名为id&lt;/strong&gt;,通过拿到的id进行查询，将查询到的基本bean封装到数据模型并返回给视图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(method = RequestMethod.GET,value = &amp;quot;/getBean&amp;quot;)
public String getBeanByParam(@RequestParam(&amp;quot;id&amp;quot;)Integer beanId, Model model){

    BaseBean bean = this.baseService.findBean(beanId);
    //以bean为key将目标对象封装到数据模型
    model.addAttribute(&amp;quot;bean&amp;quot;,bean);

    //返回试图名为home的视图
    return &amp;quot;showMessage&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后创建一个showMessage.jsp作为目标视图&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;%@ taglib prefix=&amp;quot;c&amp;quot; uri=&amp;quot;http://java.sun.com/jsp/jstl/core&amp;quot; %&amp;gt;
&amp;lt;%@ page isELIgnored=&amp;quot;false&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;信息主页&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;!--判空--&amp;gt;
    &amp;lt;c:if test=&amp;quot;${bean==null}&amp;quot;&amp;gt;
        &amp;lt;li&amp;gt;bean不存在&amp;lt;/li&amp;gt;
    &amp;lt;/c:if&amp;gt;
    &amp;lt;c:out value=&amp;quot;${bean.id}&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt;&amp;lt;!--提取目标对象的信息--&amp;gt;
    &amp;lt;c:out value=&amp;quot;${bean.name}&amp;quot;&amp;gt;&amp;lt;/c:out&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器访问路径如下：&lt;a href=&#34;http://locahost:8080/SpringAction05/getBean?id=0&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://locahost:8080/SpringAction05/getBean?id=0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_05_07.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注：其实getBeanByParam(@RequestParam(&amp;ldquo;id&amp;rdquo;)Integer id, Model model)方法中的@RequestParam(&amp;ldquo;id&amp;rdquo;)可以省略不写，如果不写的话，那么访问参数必须与参数位的名称一致，即:&lt;a href=&#34;http://locahost:8080/SpringAction05/getBean?beanId=0&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://locahost:8080/SpringAction05/getBean?beanId=0&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;②表单参数形式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将查询参数通过form表单提交到前端控制器，此时，Spring允许通过对象接收查询参数，要求form表单提交的字段与对象属性字段对应&lt;/p&gt;

&lt;p&gt;首先创建一个form表单,表单提交到/getBean&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html;charset=UTF-8&amp;quot; language=&amp;quot;java&amp;quot; %&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h2&amp;gt;Hello World!&amp;lt;/h2&amp;gt;
&amp;lt;form action=&amp;quot;./getBean&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
    提交id：&amp;lt;input name=&amp;quot;id&amp;quot; type=&amp;quot;text&amp;quot;/&amp;gt;&amp;lt;br&amp;gt;
    &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;提交&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Contorller接收参数（以对象形式）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(method = RequestMethod.POST,value = &amp;quot;/getBean&amp;quot;)
public String getBeanByForm(BaseBean baseBean, Model model){

    BaseBean bean = this.baseService.findBean(baseBean.getId());

    model.addAttribute(&amp;quot;bean&amp;quot;,bean);

    //返回试图名为home的视图
    return &amp;quot;showMessage&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器访问结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_05_08.jpg&#34; alt=&#34;&#34; /&gt;
&lt;strong&gt;③路径变量方式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SpringMVC可以通过&lt;strong&gt;@PathVariable&lt;/strong&gt;从路径中提取参数变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RequestMapping(method = RequestMethod.GET,value = &amp;quot;/getBean/{id}&amp;quot;)//指定getBean/后的参数位id参数占位
public String getBeanByPath(@PathVariable(&amp;quot;id&amp;quot;) Integer id, Model model){//通过@PathVariable注解提取变量
    BaseBean bean = this.baseService.findBean(id);

    model.addAttribute(&amp;quot;bean&amp;quot;,bean);

    //返回试图名为home的视图
    return &amp;quot;showMessage&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_05_09.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第四章：面向切面编程（AOP）</title>
      <link>https://keep-zero.github.io/2019/spring_action04/</link>
      <pubDate>Sat, 31 Aug 2019 22:42:57 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action04/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前言：DI （依赖注入）有助于应用对象之间的解耦，而 AOP（面向切面编程） 可以实现横切关注点与它们所影响的对象之间的解耦&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;一-什么是面向切面编程&#34;&gt;一、什么是面向切面编程&lt;/h2&gt;

&lt;p&gt;Ⅰ、&lt;strong&gt;横切关注点&lt;/strong&gt;：在软件开发中，散布于应用中多处的功能被称为横切关注点（ cross-cutting concern ）【比如说日志，安全和事务管理等】。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。把这些横切关注点与业务逻辑相分离正是面向切面编程（ AOP ）所要解决的问题。&lt;/p&gt;

&lt;p&gt;Ⅱ、&lt;strong&gt;切面&lt;/strong&gt;：横切关注点可以被模块化为特殊的类，这些类被称为切面（ aspect ）。&lt;/p&gt;

&lt;p&gt;Ⅲ、&lt;strong&gt;AOP术语&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;①&lt;strong&gt;通知（ Advice ）&lt;/strong&gt;：切面的工作被称为通知。通知描述切面的工作，同时决定切面何时工作【定义了切面工作做什么，什么时候做】&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;前置通知（ Before ）&lt;/strong&gt;：在目标方法被调用之前调用通知功能；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后置通知（ After ）&lt;/strong&gt;：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;返回通知（ After-returning ）&lt;/strong&gt;：在目标方法成功执行之后调用通知；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常通知（ After-throwing ）&lt;/strong&gt;：在目标方法抛出异常后调用通知；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;环绕通知（ Around ）&lt;/strong&gt;：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;②&lt;strong&gt;连接点（ Join point ）&lt;/strong&gt;：触发切面工作的点，比如方法执行，异常抛出等行为&lt;/p&gt;

&lt;p&gt;③&lt;strong&gt;切点（ Poincut ）&lt;/strong&gt;：决定切面工作的地方，比如某个方法等【定义了切面工作在哪里做】&lt;/p&gt;

&lt;p&gt;④&lt;strong&gt;切面（ Aspect ）&lt;/strong&gt;：通知和切点的结合【面】&lt;/p&gt;

&lt;p&gt;⑤&lt;strong&gt;引入（ Introduction ）&lt;/strong&gt;：允许我们向现有的类添加新方法或属性&lt;/p&gt;

&lt;p&gt;⑥&lt;strong&gt;织入（ Weaving ）&lt;/strong&gt;：把切面应用到目标对象并创建新的代理对象的过程【切面在指定的连接点被织入到目标对象中】&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;通知包含了需要用于多个应用对象的横切行为；连接点是程序执行过程中能够应用通知的所有点；切点定义了通知被应用的具体位置（在哪些连接点）。其中关键的概念是切点定义了哪些连接点会得到通知&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ⅳ、&lt;strong&gt;Spring对AOP的支持&lt;/strong&gt;【 Spring AOP 构建在动态代理基础之上，因此， Spring 对 AOP 的支持局限于方法拦截。】&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;基于代理的经典 Spring AOP ；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;纯 POJO 切面；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@AspectJ 注解驱动的切面；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注入式 AspectJ 切面（适用于 Spring 各版本）。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;二-面向切面编程实现&#34;&gt;二、面向切面编程实现&lt;/h2&gt;

&lt;h3 id=&#34;1-定义切点&#34;&gt;1、定义切点：&lt;/h3&gt;

&lt;p&gt;Spring支持通过&lt;strong&gt;AspectJ&lt;/strong&gt;的切点表达式语言来定义 Spring 切面，同时增加通过bean的id指定bean的写法。&lt;/p&gt;

&lt;p&gt;如：&lt;strong&gt;execution(* com.my.spring.bean.&lt;em&gt;.&lt;/em&gt;(..))&lt;/strong&gt; 指定com.my.spring.bean包下所有类的所有方法作为切点&lt;/p&gt;

&lt;p&gt;其结构解析如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://keep-zero.github.io/images/post_resource/spring-action/spring_action_04.jpg&#34; alt=&#34;&#34; /&gt;
AspectJ切点表达式的指示器不只有execution：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;arg()&lt;/strong&gt; ：限制连接点匹配参数为指定类型的执行方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;execution()&lt;/strong&gt; ：用于匹配是连接点的执行方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;this()&lt;/strong&gt; ：限制连接点匹配 AOP 代理的 bean 引用为指定类型的类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;target&lt;/strong&gt; ：限制连接点匹配目标对象为指定类型的类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;within()&lt;/strong&gt; ：限制连接点匹配指定的类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;各指示器之间可以通过&lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;（与），&lt;strong&gt;||&lt;/strong&gt;（或），&lt;strong&gt;!&lt;/strong&gt;（非）连接符进行连接实现多条件查询定义节点&lt;/p&gt;

&lt;p&gt;如：execution(* com.my.spring.bean.* . *(..))&amp;amp;&amp;amp;arg(java.lang.Integer)&lt;/p&gt;

&lt;h3 id=&#34;2-示例demo&#34;&gt;2.示例Demo&lt;/h3&gt;

&lt;p&gt;Spring AOP的实现依赖于spring-aop包和aspectjweaver包，需在pom文件引入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-aop&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${org.springframework.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.8.13&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过实例demo引入概念：&lt;/p&gt;

&lt;p&gt;①定义一个基础接口类BaseInterface和实现类BaseBean&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface BaseInterface {

    /**
     * 新增歌曲
     *
     * @param author 作者
     * @param songTitle 歌曲名
     *
     * @return java.lang.Integer 返回当前歌曲总数
     *
     * @author xxx 2019/3/4
     * @version 1.0
     **/
    Integer addSong(String author,String songTitle);

    /**
     * 删除歌曲
     *
     * @param author 作者
     * @param songTitle 歌曲名
     *
     * @return java.lang.Integer 返回当前歌曲总数
     *
     * @author xxx 2019/3/4
     * @version 1.0
     **/
    Integer delSong(String author,String songTitle);
}

@Component
public class BaseBean implements  BaseInterface{

    private String author;
    private String songTitle;
    private Integer count=0;

    @Override
    public Integer addSong(String author,String songTitle){
        this.author = author;
        this.songTitle = songTitle;
        System.out.println(&amp;quot;新增了一首歌：&amp;quot;+author+&amp;quot;-&amp;quot;+songTitle);
        count++;
        return count;
    }

    @Override
    public Integer delSong(String author,String songTitle){
        this.author = author;
        this.songTitle = songTitle;
        System.out.println(&amp;quot;删除了一首歌：&amp;quot;+author+&amp;quot;-&amp;quot;+songTitle);
        count--;
        return count;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②创建一个&lt;strong&gt;切面类&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Aspect
@Component
public class BaseBeanAspect {

    private Logger logger = LoggerFactory.getLogger(BaseBeanAspect.class);

     /**
      * 方法执行前的通知
      */
    @Before(&amp;quot;execution(* com.my.spring.bean.*.*(..))&amp;quot;)
    public void beforeInvoke(){
        logger.debug(&amp;quot;方法执行前&amp;quot;);
    }

    /**
     * 方法执行后的通知
     */
    @After(&amp;quot;execution(* com.my.spring.bean.*.*(..))&amp;quot;)
    public void afterInvoke(){
        logger.debug(&amp;quot;方法执行后&amp;quot;);
    }

    /**
     * 方法执行返回后的通知
     */
    @AfterReturning(&amp;quot;execution(* com.my.spring.bean.*.*(..))&amp;quot;)
    public void afterReturning(){
        logger.debug(&amp;quot;==================方法执行完成&amp;quot;);
    }

    /**
     * 方法抛出异常的通知
     */
    @AfterThrowing(&amp;quot;execution(* com.my.spring.bean.*.*(..))&amp;quot;)
    public void afterThrowing(){

        logger.debug(&amp;quot;==================方法执行报错&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③创建自动化装配的配置类&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Configuration
@EnableAspectJAutoProxy//开启自动代理开关，启用切面
@ComponentScan(basePackages = {&amp;quot;com.my.spring&amp;quot;})
public class ComponentConfig {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;④测试&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = {ComponentConfig.class})
public class AppTest {

    @Autowired
    private BaseInterface baseInterface;

    @Test
    public void testBean(){
        baseInterface.addSong(&amp;quot;myBean&amp;quot;,&amp;quot;mySong&amp;quot;);
        baseInterface.delSong(&amp;quot;myBean&amp;quot;,&amp;quot;mySong&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;⑤测试结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;2019-03-04 14:32:55.019 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法执行前
新增了一首歌：myBean-mySong
2019-03-04 14:32:55.019 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法执行后
2019-03-04 14:32:55.019 DEBUG com.my.spring.aspect.BaseBeanAspect - ==================方法执行完成
2019-03-04 14:32:55.019 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法执行前
删除了一首歌：myBean-mySong
2019-03-04 14:32:55.019 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法执行后
2019-03-04 14:32:55.019 DEBUG com.my.spring.aspect.BaseBeanAspect - ==================方法执行完成
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-注解分析&#34;&gt;3、注解分析&lt;/h3&gt;

&lt;p&gt;前代码是使用注解实现SpringAOP的简单示例，我们了解以下其中用到的注解和实现：&lt;/p&gt;

&lt;p&gt;Ⅰ、&lt;strong&gt;定义切面：@Aspect&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;标识当前类是一个切面类（仅仅只是标识，我们可以看到该注解源码并没有使用@Component注解，所以使用该注解的bean依旧只是一个普通的POJO，使用时依旧需要显式或自动装配）&lt;/p&gt;

&lt;p&gt;Ⅱ、&lt;strong&gt;定义切点：@PointCut&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们看到上述代码中在多个地方使用切点使用的是重复性的表达式，其实通过@PointCut注解定义切点，同时通过指定空方法名引入切点到各个通知即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Pointcut(&amp;quot;execution(* com.my.spring.bean.*.*(..))&amp;quot;)
public void pointCut(){//被用于标识的空方法
}

@Before(&amp;quot;pointCut()&amp;quot;)//以切点方法名引入
public void beforeInvoke(){
    logger.debug(&amp;quot;方法执行前&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ⅱ、&lt;strong&gt;定义通知:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@Beafore(切点)&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;切点方法执行前的通知&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@After(切点）&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-切点方法执行后的通知&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@AfterReturning(切点）&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;切点方法执行返回后的通知&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@AfterThrowing(切点）&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;切点方法抛异常后的通知&lt;/p&gt;

&lt;p&gt;Ⅲ、&lt;strong&gt;开启自动代理：@EnableAspectJAutoProxy&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;ndash;在配置类中使用，如果不启用的话，编写的切面将不生效&lt;/p&gt;

&lt;p&gt;Ⅳ、&lt;strong&gt;定义环绕通知：@Around(&amp;ldquo;pointCut()&amp;rdquo;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;环绕通知是&lt;strong&gt;从方法执行前一直包裹直到方法执行完成后的一个通知&lt;/strong&gt;，用的比较多，其中被定义的方法需要引入参数&lt;strong&gt;ProceedingJoinPoint&lt;/strong&gt;,ProceedingJoinPoint对象封装了当前运行对象的具体信息，简单实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; @Around(&amp;quot;pointCut()&amp;quot;)
public void aroundInvoke(ProceedingJoinPoint jp){
    try {
        logger.debug(&amp;quot;=====================环绕执行方法开始&amp;quot;);
        Signature signature = jp.getSignature();
        String methodName = signature.getName();
        MethodSignature methodSignature = (MethodSignature) signature;
        logger.debug(&amp;quot;方法名:{}&amp;quot;,methodName);
        List&amp;lt;Object&amp;gt; args = Arrays.asList(jp.getArgs());
       logger.debug(&amp;quot;参数列表：{}&amp;quot;,args);
       Class&amp;lt;?&amp;gt; returnType = methodSignature.getMethod().getReturnType();
       logger.debug(&amp;quot;方法返回类型：{}&amp;quot;,returnType);
       Object proceed = jp.proceed();
       logger.debug(&amp;quot;======================环绕执行方法结束，方法执行结果:{}&amp;quot;,proceed);
     } catch (Throwable throwable) {
         throwable.printStackTrace();
     }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，&lt;strong&gt;ProceedingJoinPoint&lt;/strong&gt;对象源码分析如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;JoinPoint 

     java.lang.Object[] getArgs()//获取连接点方法运行时的入参列表； 

     Signature getSignature() //获取连接点的方法签名对象； 

     java.lang.Object getTarget() //获取连接点所在的目标对象； 

     java.lang.Object getThis() //获取代理对象本身； 

ProceedingJoinPoint继承JoinPoint子接口，它新增了两个用于执行连接点方法的方法

      java.lang.Object proceed() throws java.lang.Throwable：通过反射执行目标对象的连接点处的方法；

      java.lang.Object proceed(java.lang.Object[] args) throws java.lang.Throwable：通过反射执行目标对象连接点处的方法，不过使用新的入参替换原来的入参。 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-xml实现切面编程&#34;&gt;4、XML实现切面编程&lt;/h3&gt;

&lt;p&gt;我们知道使用注解实现切面编程是很方便直接的，但是有时候我们并不一定拥有通知类的源码，也就无法给对应的方法添加注解，这时候就需要使用XML配置实现了。XML配置实现与注解实现十分类似，我们可以看一下基本的实现节点：&lt;/p&gt;

&lt;p&gt;①&lt;strong&gt;定义切面：&lt;aop:aspect ref=&#34;切面类在xml文件中对应bean的id&#34;&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;②&lt;strong&gt;定义切点：&lt;aop:pointcut id=&#34;切点id&#34; expression=&#34;切点表达式&#34;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;③&lt;strong&gt;定义通知：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;aop:beafore method=&#34;通知方法名&#34; pointcut-ref=&#34;切点id&#34;/&gt;&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-定义方法执行前的通知&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;aop:after method=&#34;通知方法名&#34; pointcut-ref=&#34;切点id&#34;/&gt;&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-定义方法执行后的通知&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;aop:afterReturning method=&#34;通知方法名&#34; pointcut-ref=&#34;切点id&#34;/&gt;&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-定义方法执行返回后的通知&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;aop:afterThrowing method=&#34;通知方法名&#34; pointcut-ref=&#34;切点id&#34;/&gt;&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-定义方法执行抛出异常后的通知&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;aop:around method=&#34;通知方法名&#34; pointcut-ref=&#34;切点id&#34;/&gt;&lt;/strong&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-定义方法环绕通知&lt;/p&gt;

&lt;p&gt;④开启自动代理：&lt;strong&gt;&lt;a href=&#34;aop:aspectj-autoproxy/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;aop:aspectj-autoproxy/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;⑤表示aop配置：&lt;strong&gt;&lt;a href=&#34;aop:config&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;aop:config&lt;/a&gt;&lt;a href=&#34;https://keep-zero.github.io/aop:config&#34;&gt;/aop:config&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;除了开启自动代理，aop的所有节点都需要包含在&lt;strong&gt;&lt;a href=&#34;aop:config&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;aop:config&lt;/a&gt;&lt;a href=&#34;https://keep-zero.github.io/aop:config&#34;&gt;/aop:config&lt;/a&gt;节点中&lt;/strong&gt;，如下demo演示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;applicaiton.xml
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;beans xmlns=&amp;quot;http://www.springframework.org/schema/beans&amp;quot;
       xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xmlns:aop=&amp;quot;http://www.springframework.org/schema/aop&amp;quot;
       xsi:schemaLocation=&amp;quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&amp;quot;&amp;gt;
    &amp;lt;!--开启自动代理--&amp;gt;
    &amp;lt;aop:aspectj-autoproxy/&amp;gt;

    &amp;lt;!--装配基本类--&amp;gt;
    &amp;lt;bean class=&amp;quot;com.my.spring.bean.BaseBean&amp;quot; id=&amp;quot;baseBean&amp;quot; name=&amp;quot;baseBean&amp;quot;/&amp;gt;

    &amp;lt;!--装配切面类--&amp;gt;
    &amp;lt;bean class=&amp;quot;com.my.spring.aspect.BaseBeanAspect&amp;quot; id=&amp;quot;baseBeanAspect&amp;quot;/&amp;gt;

    &amp;lt;!--aop配置--&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!--配置切面--&amp;gt;
        &amp;lt;aop:aspect ref=&amp;quot;baseBeanAspect&amp;quot;&amp;gt;
            &amp;lt;!--定义切点--&amp;gt;
            &amp;lt;aop:pointcut id=&amp;quot;pointCut&amp;quot; expression=&amp;quot;execution(* com.my.spring.bean.*.*(..))&amp;quot;/&amp;gt;
            &amp;lt;!--定义前置通知--&amp;gt;
            &amp;lt;aop:before method=&amp;quot;beforeInvoke&amp;quot; pointcut-ref=&amp;quot;pointCut&amp;quot;/&amp;gt;
            &amp;lt;!--定义后置通知--&amp;gt;
            &amp;lt;aop:after method=&amp;quot;afterInvoke&amp;quot; pointcut-ref=&amp;quot;pointCut&amp;quot;/&amp;gt;
            &amp;lt;!--定义方法执行返回后通知--&amp;gt;
            &amp;lt;aop:after-returning method=&amp;quot;afterReturning&amp;quot; pointcut-ref=&amp;quot;pointCut&amp;quot;/&amp;gt;
            &amp;lt;!--定义方法异常后通知--&amp;gt;
            &amp;lt;aop:after-throwing method=&amp;quot;afterThrowing&amp;quot; pointcut-ref=&amp;quot;pointCut&amp;quot;/&amp;gt;
            &amp;lt;!--定义方法环绕通知通知--&amp;gt;
            &amp;lt;aop:around method=&amp;quot;aroundInvoke&amp;quot; pointcut-ref=&amp;quot;pointCut&amp;quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将BaseBean和BaseBeanAspect类中的注解去除，编写测试类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&amp;quot;classpath:application.xml&amp;quot;})//将配置文件作为装配环境
public class AppXMLTest {

    @Autowired
    private BaseInterface baseInterface;

    @Test
    public void testBean(){
        baseInterface.addSong(&amp;quot;Mr D&amp;quot;,&amp;quot;The World!!&amp;quot;);
        baseInterface.delSong(&amp;quot;Mr D&amp;quot;,&amp;quot;The World!!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;测试结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;2019-03-04 22:07:37.901 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法执行前
2019-03-04 22:07:37.903 DEBUG com.my.spring.aspect.BaseBeanAspect - =====================环绕执行方法开始
2019-03-04 22:07:37.907 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法名:addSong
2019-03-04 22:07:37.910 DEBUG com.my.spring.aspect.BaseBeanAspect - 参数列表：[Mr D, The World!!]
2019-03-04 22:07:37.910 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法返回类型：class java.lang.Integer
2019-03-04 22:07:37.910 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法执行前
新增了一首歌：Mr D-The World!!
2019-03-04 22:07:37.911 DEBUG com.my.spring.aspect.BaseBeanAspect - ==================方法执行完成
2019-03-04 22:07:37.911 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法执行后
2019-03-04 22:07:37.911 DEBUG com.my.spring.aspect.BaseBeanAspect - ======================环绕执行方法结束，方法执行结果:1
2019-03-04 22:07:37.912 DEBUG com.my.spring.aspect.BaseBeanAspect - ==================方法执行完成
2019-03-04 22:07:37.912 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法执行后
2019-03-04 22:07:37.915 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法执行前
2019-03-04 22:07:37.915 DEBUG com.my.spring.aspect.BaseBeanAspect - =====================环绕执行方法开始
2019-03-04 22:07:37.916 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法名:delSong
2019-03-04 22:07:37.917 DEBUG com.my.spring.aspect.BaseBeanAspect - 参数列表：[Mr D, The World!!]
2019-03-04 22:07:37.917 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法返回类型：class java.lang.Integer
2019-03-04 22:07:37.917 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法执行前
删除了一首歌：Mr D-The World!!
2019-03-04 22:07:37.917 DEBUG com.my.spring.aspect.BaseBeanAspect - ==================方法执行完成
2019-03-04 22:07:37.917 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法执行后
2019-03-04 22:07:37.917 DEBUG com.my.spring.aspect.BaseBeanAspect - ======================环绕执行方法结束，方法执行结果:0
2019-03-04 22:07:37.917 DEBUG com.my.spring.aspect.BaseBeanAspect - ==================方法执行完成
2019-03-04 22:07:37.917 DEBUG com.my.spring.aspect.BaseBeanAspect - 方法执行后
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>《Spring实战》-第三章：Bean的高级装配(总目录)</title>
      <link>https://keep-zero.github.io/2019/spring_action03_06/</link>
      <pubDate>Sat, 31 Aug 2019 22:35:43 +0800</pubDate>
      
      <guid>https://keep-zero.github.io/2019/spring_action03_06/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;慢慢来比较快，虚心学技术&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/9f326feaf440&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;《Spring实战》-第三章：Bean的高级装配（1）-环境Profile&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/63d9a25e2bba&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;《Spring实战》-第三章：Bean的高级装配（2）-条件化Bean&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/7497e644ad52&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;《Spring实战》-第三章：Bean的高级装配（3）-处理自动装配Bean的歧义性&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/24f481c6c513&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;《Spring实战》-第三章：Bean的高级装配（4）-Bean的作用域&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/24f481c6c513&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;《Spring实战》-第三章：Bean的高级装配（5）-运行时值注入&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>